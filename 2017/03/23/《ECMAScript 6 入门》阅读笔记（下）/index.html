<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 《ECMAScript 6入门》阅读笔记（下） · 易浮的小窝</title><meta name="description" content="《ECMAScript 6入门》阅读笔记（下） - Hyifu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/Hyifu/atom.xml" title="易浮的小窝"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"><h1>易浮的小窝</h1></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">《ECMAScript 6入门》阅读笔记（下）</h1><div class="post-info">Mar 23, 2017</div><div class="post-content"><p>下半部分，主要考量了全新的异步模式 Promise 和 Generator 以及它们的语法糖 async。当然，还有超级好用的的模块实现，以及让人头大的的类，这里建议配合<a href="https://item.jd.com/12030814.html" target="_blank" rel="external">《你不知道的JavaScript（中）》</a>的第二部分反复阅读，理解 JavaScript 强大的异步实现</p>
<p><img src="/images/ECMAScript6入门.jpg" alt="ECMAScript6入门"></p>
<a id="more"></a>
<h2 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h2><blockquote>
<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大</p>
</blockquote>
<ul>
<li>两个特点<ul>
<li>Promise 对象有三种状态：Pending、Resolved 和 Rejected。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果</li>
<li>无法取消 Promise，一旦新建它就会立即执行，无法中途取消</li>
<li>如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部</li>
<li>处于 Pending 状态时，无法得知目前进展到哪一个阶段</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(resolve, reject) &#123;</div><div class="line">	<span class="comment">// promise 这里会立即执行</span></div><div class="line">	<span class="keyword">if</span> (<span class="literal">true</span>) &#123; <span class="comment">// 异步成功</span></div><div class="line">		resolve(value) <span class="comment">// 把 value 作为参数传出去</span></div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'报错啦'</span>)) <span class="comment">// 通常是 Error 对象的实例</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// then 方法的第二个参数一般不建议使用，使用 .catch() 替代，使代码更优雅可读，同时可捕捉回调函数中抛出的错误</span></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">	<span class="comment">// 处理结果</span></div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</div><div class="line">	<span class="comment">// 相当于 .then(null, function (error) &#123;..&#125;)</span></div><div class="line">	<span class="comment">// 处理错误</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li><p>resolve 的参数可以也可是一个 promise 实例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;)</div><div class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  resolve(p1) <span class="comment">// 在这里，p1 的状态就传给了 p2，会等待 p1 的状态决议后才执行</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p><code>Promise.prototype.then()</code></p>
<blockquote>
<p>本方法接受两个参数 <code>resolve</code> 和 <code>reject</code>（但不建议使用第二个参数，而是使用 <code>.catch()</code> 方法替代），返回一个新的 Promise 实例（不是原来那个），因此可以使用链式继续调用 <code>.then()</code> 方法</p>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> json.post <span class="comment">// 这里返回的结果作为参数传给下一个 then 调用</span></div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</div><div class="line">  <span class="comment">// 如果 post 是另外一个 promise，则会等待该 promise 决议</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<ul>
<li><p><code>Promise.all()</code> 方法用于多个 promise 实例</p>
<ul>
<li>全部 promise 都变成 resolve，才返回 resolve</li>
<li>只要有一个 reject，返回第一个 reject 那个</li>
</ul>
</li>
<li><p><code>Promise.race()</code>  返回最先被决议的那个 promise</p>
</li>
<li><code>Promise.resolve()</code> 方法会将一个普通对象转换成 Promise 对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</div><div class="line"><span class="comment">// 等价于</span></div><div class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">'foo'</span>))</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Iterator-和-for…of-循环"><a href="#Iterator-和-for…of-循环" class="headerlink" title="Iterator 和 for…of 循环"></a>Iterator 和 for…of 循环</h2><blockquote>
<p><code>Iterator</code> 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令 <code>for...of</code> 循环，Iterator 接口主要供 <code>for...of</code> 消费</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> it = makeIterator([<span class="string">'a'</span>, <span class="string">'b'</span>]);</div><div class="line"></div><div class="line">it.next() <span class="comment">// &#123; value: "a", done: false &#125;</span></div><div class="line">it.next() <span class="comment">// &#123; value: "b", done: false &#125;</span></div><div class="line">it.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></div><div class="line"><span class="comment">// 手动模拟一个迭代器</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> nextIndex &lt; array.length ?</div><div class="line">        &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; :</div><div class="line">        &#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在ES6中，有三类数据结构原生具备 Iterator 接口：数组、某些类似数组的对象、Set 和 Map 结构</li>
</ul>
<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><blockquote>
<p>用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的 <code>next</code> 方法，就会返回一个有着 <code>value</code> 和 <code>done</code> 两个属性的对象。<code>value</code> 属性表示当前的内部状态的值，是 <code>yield</code> 语句后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束</p>
</blockquote>
<ul>
<li>Generator 函数本质上还是函数，但这个函数可以分段执行返回</li>
<li>Generator 函数可以不用 <code>yield</code> 语句，这时就变成了一个单纯的暂缓执行函数。但 <code>yield</code> 语句只能用在 Generator 函数中</li>
<li>Generator 函数是 ES6 新增的底层实现，跟 Promise 不同</li>
<li><p>使普通对象具备迭代器接口</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myIterable = &#123;&#125;;</div><div class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//</span></div><div class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>yield</code> 句本身没有返回值，或者说总是返回 <code>undefined</code>。<code>next</code> 方法可以带一个参数，该参数就会被当作上一个 <code>yield</code> 语句的返回值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; <span class="literal">true</span>; i++) &#123;</div><div class="line">    <span class="keyword">var</span> reset = <span class="keyword">yield</span> i;</div><div class="line">    <span class="keyword">if</span>(reset) &#123; i = <span class="number">-1</span>; &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为</span></div><div class="line"><span class="keyword">var</span> g = f();</div><div class="line">g.next() <span class="comment">// &#123; value: 0, done: false &#125;</span></div><div class="line">g.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></div><div class="line">g.next(<span class="literal">true</span>) <span class="comment">// &#123; value: 0, done: false &#125;</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>for...of</code> 循环可以自动遍历 Generator 函数时生成的 Iterator 对象，且此时不再需要调用 <code>next</code> 方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</div><div class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</div><div class="line">  <span class="keyword">return</span> <span class="number">6</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(v);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 1 2 3 4 5 不包含返回对象</span></div></pre></td></tr></table></figure>
</li>
<li><p>配合 <code>try...catch</code> 和 <code>Generator.throw()</code> 方法，可以方便地根据需要在函数内外捕获错误</p>
</li>
<li><code>Generator.return()</code> 方法可以返回值并停止迭代</li>
<li><code>yield*</code>后面的 Generator 函数（没有 return 语句时），不过是 <code>for...of</code> 的一种简写形式，完全可以用后者替代前者。反之，则需要用 <code>var value = yield* iterator</code> 的形式获取 <code>return</code> 语句的值</li>
<li>任何数据结构只要有 Iterator 接口，就可以被 <code>yield*</code> 遍历</li>
<li>其返回的 Promise 对象的只在所有异步状态都完成后才决议（除非提前 return 或抛出错误），非常类似 Promise.all</li>
<li>使用 Generator 包装一个对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">objectEntries</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> propKeys = <span class="built_in">Reflect</span>.ownKeys(obj)</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> propKey <span class="keyword">of</span> propKeys) &#123;</div><div class="line">    <span class="keyword">yield</span> [propKey, obj[propKey]]</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> jane = &#123; <span class="attr">first</span>: <span class="string">'Jane'</span>, <span class="attr">last</span>: <span class="string">'Doe'</span> &#125;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> objectEntries(jane)) &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="async-函数（ES2017）"><a href="#async-函数（ES2017）" class="headerlink" title="async 函数（ES2017）"></a>async 函数（ES2017）</h2><blockquote>
<p>是 Generator 函数的语法糖</p>
</blockquote>
<ul>
<li>自带执行器，因此不用手动调用 <code>next()</code>，可以看作是多个异步操作包装成的 Promise 对象，因此下一步通常是调用 <code>then</code> 方法进行处理，本质上等于把 Generator 和它的执行期封装在一个函数中</li>
<li>具备五种定义方法<ul>
<li>函数声明</li>
<li>函数表达式</li>
<li>对象方法</li>
<li>类</li>
<li>箭头函数</li>
</ul>
</li>
<li><code>await</code> 命令后面一定是一个 Promise 对象（自动包装）</li>
<li>为了能方便捕获错误，最好讲 <code>await</code> 操作放在 <code>try...catch</code> 中<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">await</span> somethingThatReturnsAPromise()</div><div class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</div><div class="line">    <span class="built_in">console</span>.log(err)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><ul>
<li><p>基本应用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name</div><div class="line">	<span class="keyword">this</span>.age = age</div><div class="line">&#125;</div><div class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ES6</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span> (name, age) &#123;</div><div class="line">		<span class="keyword">this</span>.name = name</div><div class="line">		<span class="keyword">this</span>.age = age</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//</span></div><div class="line">	getName () &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>Class</code> 必须用 <code>new</code> 调用，否则报错，同时不存在变量提升</p>
</li>
<li>与ES5不同的地方是，<code>Class</code> 定义的方法是不可枚举的</li>
<li><code>constructor</code> 方法是类的默认方法，如果不指定，则默认添加一个空方法</li>
<li><code>Class</code> 中默认就是严格模式</li>
<li>类之间通过 <code>extends</code> 关键字实现继承<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ColorPoint 类，该类通过 extends 关键字，继承了 Point 类的所有属性和方法</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;&#125; <span class="comment">// 这里相当于复制</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</div><div class="line">	<span class="comment">// 子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工</span></div><div class="line">  <span class="keyword">constructor</span>(x, y, color) &#123;</div><div class="line">    <span class="keyword">super</span>(x, y); <span class="comment">// 调用父类的 constructor(x, y)</span></div><div class="line">    <span class="keyword">this</span>.color = color;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  toString() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.color + <span class="string">' '</span> + <span class="keyword">super</span>.toString(); <span class="comment">// 调用父类的 toString()</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><ul>
<li>CommonJS 与 ES6 的区别<ul>
<li>CommonJS 先生成对象再读取其中的方法，运行时加载，无法静态优化；ES6 模块不是对象，编译时加载，可实现静态优化</li>
<li>CommonJS 输出的是值的缓存，不存在动态更新；ES6 模块输出的是值的引用</li>
</ul>
</li>
<li>ES6 中的模块自动采用严格模式</li>
<li><code>export</code> 命令，输出模块的变量（否则外部无法读取），该命令不能出现在块作用域中</li>
<li><code>import</code> 命令加载模块并读取其中变量，该命令有提升作用，自动提升到整个模块头部优先执行，该命令不能出现在块作用域中</li>
<li><code>import</code> 是静态执行的，所以不能使用表达式和变量这些运行时语法，该命令是 Singleton 模式</li>
<li>使用默认输出时，<code>import</code>语句无需大括号</li>
<li>浏览器中使用模块，该模块默认为延迟脚本<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"foo.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2017/04/16/前端性能优化小扎/" class="prev">PREV</a><a href="/2017/03/08/《ECMAScript 6 入门》阅读笔记（上）/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="https://github.com/Hyifu">Hyifu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>