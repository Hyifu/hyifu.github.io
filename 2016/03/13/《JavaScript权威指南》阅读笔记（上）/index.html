<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 《JavaScript权威指南》阅读笔记（上） · 易浮的小窝</title><meta name="description" content="《JavaScript权威指南》阅读笔记（上） - Hyifu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/Hyifu/atom.xml" title="易浮的小窝"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"><h1>易浮的小窝</h1></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">《JavaScript权威指南》阅读笔记（上）</h1><div class="post-info">Mar 13, 2016</div><div class="post-content"><p>断续读完了 JavaScript 开发者眼中的圣经，总之，真是厚厚的一本手册，上千页的非常详细的介绍，大部分是基于 API 的细节，因此很多东西其实是没必要做笔记的（没必要的意思是，随着阅历的增加，很多特性你也许已经了然于胸，但不管怎样，圣经就是圣经，我觉得有空多看两遍核心部分是很有裨益的），因此这里只列出一些核心点和容易被疏漏的地方，首先是第一部分，关于语言的核心</p>
<p><img src="/images/JavaScript权威指南.jpg" alt="JavaScript权威指南"></p>
<a id="more"></a>
<blockquote>
<p>作者 <strong>David Flanagan</strong>，封面动物：爪哇犀牛 - Javan rhinoceros</p>
</blockquote>
<h2 id="词法结构"><a href="#词法结构" class="headerlink" title="词法结构"></a>词法结构</h2><ul>
<li><strong>JavaScript</strong> 使用 <code>unicode</code> 编码</li>
<li>分号解析规则：缺少分号无法解析代码的时候（因此以 <code>(</code> 或 <code>[</code> 开始的代码很大可能与前面的语句一起解析）</li>
</ul>
<h2 id="类型、值和变量"><a href="#类型、值和变量" class="headerlink" title="类型、值和变量"></a>类型、值和变量</h2><ul>
<li>两种数据类型<ul>
<li>基本类型（Primitive），也是不可变类型<ul>
<li>Number</li>
<li>String</li>
<li>Boolean</li>
<li>Null</li>
<li>Undefined       </li>
<li>Symbol</li>
</ul>
</li>
<li>对象（Object），也是可变类型<ul>
<li>数组 Array</li>
<li>函数 Function</li>
<li>其他（包括 Date、RegExp 等）</li>
</ul>
</li>
</ul>
</li>
<li><p>字符串换行技巧</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 通用</span></div><div class="line"><span class="keyword">var</span> str1 = <span class="string">''</span>+</div><div class="line">    <span class="string">'line1'</span>+</div><div class="line">    <span class="string">'line2'</span></div><div class="line"></div><div class="line"><span class="comment">// ES5</span></div><div class="line"><span class="keyword">var</span> str2 = <span class="string">'\</span></div><div class="line">    line1\</div><div class="line">    line2'</div><div class="line"></div><div class="line"><span class="comment">// ES6</span></div><div class="line"><span class="keyword">var</span> str3 = <span class="string">`</span></div><div class="line">    line1</div><div class="line">    line2</div><div class="line">`</div></pre></td></tr></table></figure>
</li>
<li><p>转换为 <code>false</code> 的六个值，其他均为 <code>true</code></p>
<ul>
<li>undefined</li>
<li>null</li>
<li>0</li>
<li>-0</li>
<li>NaN</li>
<li>“”（空字符串）</li>
</ul>
</li>
<li><code>null</code> 与 <code>undefined</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> <span class="literal">null</span> === <span class="string">'object'</span> <span class="comment">// true, 表明是一个空对象</span></div><div class="line"><span class="comment">// 而 undefined 则指代一种更深层次的空 =&gt; 未定义或不存在</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="表达式和运算符"><a href="#表达式和运算符" class="headerlink" title="表达式和运算符"></a>表达式和运算符</h2><ul>
<li><p>前后自增量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i = <span class="number">1</span>, j = ++i <span class="comment">// i和j的值都是2，前增量 pre-increment，赋值前自增</span></div><div class="line"><span class="keyword">var</span> i = <span class="number">1</span>, j = i++ <span class="comment">// i是2，j是1，后增量 post-increment</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>NaN</code> 与任何值不相等，包括本身</p>
</li>
<li><p><code>in</code> 操作符用来检测对象的属性是否存在</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> data = [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</div><div class="line"><span class="string">'0'</span> <span class="keyword">in</span> data === <span class="literal">true</span> <span class="comment">// true 因为存在索引0，可以转换成字符串 '0'</span></div></pre></td></tr></table></figure>
</li>
<li><p>通过 <code>delete</code> 操作符删除数组元素并不会修改数组长度</p>
</li>
</ul>
<h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><ul>
<li>函数或声明不应该放在除函数外的代码块中</li>
<li>在函数中，<code>switch</code> 中的 <code>break</code> 可以用 <code>return</code> 实现</li>
<li><code>break</code> 不同通过标签跳转到函数外部</li>
<li><code>catch</code> 语句中花括号是有块级作用域的</li>
</ul>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj1 = &#123;</div><div class="line">  <span class="string">'current age'</span>: <span class="number">26</span>, <span class="comment">// 空格或连字符做属性要加引号</span></div><div class="line">  <span class="string">'for'</span>: <span class="string">'wife'</span>, <span class="comment">// 保留字，ES3 中必须加引号，建议一致加引号</span></div><div class="line">  name: <span class="string">'james'</span>, <span class="comment">// ES3 中此逗号在 IE 中会报错，建议去除</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.create(<span class="literal">null</span>) <span class="comment">// 不会继承任何属性和方法</span></div><div class="line"><span class="keyword">var</span> obj3 = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype) <span class="comment">// 相当于 var obj3 = &#123;&#125;</span></div></pre></td></tr></table></figure>
<ul>
<li>每一个对象都具有原型（<code>null</code> 与 <code>Object.prototype</code> 除外）</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li><p>稀疏数组，数组的长度大于数组项的数量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 产生稀疏数组</span></div><div class="line"><span class="keyword">var</span> a1 = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>);</div><div class="line"><span class="keyword">var</span> a2 = []</div><div class="line">a2.length = <span class="number">5</span></div><div class="line"><span class="keyword">var</span> a3 = [, , ,]</div><div class="line"><span class="keyword">var</span> a4 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</div><div class="line"><span class="keyword">delete</span> a4[<span class="number">1</span>] <span class="comment">// 等同于[1, , 3, 4]</span></div></pre></td></tr></table></figure>
</li>
<li><p>压缩数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="literal">undefined</span>, , , <span class="number">3</span>, <span class="literal">null</span>]</div><div class="line"><span class="comment">// b === [1, undefined, 3, null], 稀疏数组被压缩</span></div><div class="line">b = a.filter(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// c === [1,3],  进一步压缩 undefined 和 null</span></div><div class="line">c = a.filter(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x !== <span class="literal">undefined</span> &amp;&amp; x !== <span class="literal">null</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>空数组调用 <code>.every()</code> / <code>.some()</code> 总是返回 <code>true</code> / <code>false</code></p>
</li>
<li><p>如何判断一个未知对象是否为数组（只有两种方法）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>()</div><div class="line"><span class="built_in">Array</span>.isArray(arr) <span class="comment">//true, ES5+</span></div><div class="line"><span class="built_in">Object</span>.prototype.toString(arr) === <span class="string">'[object Array]'</span> <span class="comment">// ES3</span></div></pre></td></tr></table></figure>
</li>
<li><p>字符串可看成是只读的类数组对象，方便进行各种操作</p>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li>不要将函数声明在代码块中（可换成表达式）</li>
<li><p>非严格模式中，直接调用函数时其内部的 <code>this</code> 指向全局对象，作为对象的方法调用时则指向方法所属对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 判断函数是否在严格模式中运行</span></div><div class="line"><span class="keyword">var</span> strict = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> !<span class="keyword">this</span> &#125;())</div></pre></td></tr></table></figure>
</li>
<li><p>方法的链式调用——当方法不需要返回值时，直接返回 <code>this</code></p>
</li>
<li><code>callee</code> 指向当前正在执行的函数，而 <code>caller</code> 则指向调用当前函数的函数（严格模式中禁用）</li>
<li><p>函数是一种特殊的对象，可以拥有属性（类似构造函数）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如下例子，直接使用函数的属性存储外部初始值（每次调用函数都是0）， 而省去一次变量声明来存储初始值</span></div><div class="line">uniqueInterger.counter = <span class="number">0</span> <span class="comment">// 函数声明提前</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueInterger</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> uniqueInterger.counter++</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 函数同样可以把自己当成一个数组来使用，如下例子</span></div><div class="line"><span class="comment">// 计算阶乘，并将结果缓存到函数的属性中</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">factirual</span> (<span class="params">n</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!(n <span class="keyword">in</span> factorial)) &#123; <span class="comment">// 如果没有缓存结果</span></div><div class="line">    factorial[n] = n * factorial(n<span class="number">-1</span>) <span class="comment">// 计算结果并缓存</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> factorial[n] <span class="comment">// 返回缓存的结果</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>技术角度上讲，所有的函数都是闭包。一般认为闭包是在函数中返回的另一个函数</p>
</li>
<li>函数的 <code>length</code> 为期待的形参个数，而 <code>argument.length</code> 则为实际传入实参个数</li>
<li><code>call()</code> 和 <code>apply()</code> 方法类似，第一个参数会绑定为 <code>this</code> 的值，apply参数传入放在一个数组中；而 <code>bind()</code> 是ES5+方法，绑定所有实参到对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// f.call(o) 或 f.apply(o) 的实际调用类似下面</span></div><div class="line">o.m = f; <span class="comment">// 将f存储为o的临时方法</span></div><div class="line">o.m(); <span class="comment">// 调用临时方法</span></div><div class="line"><span class="keyword">delete</span> o.m; <span class="comment">// 将临时方法删除</span></div><div class="line"></div><div class="line"><span class="comment">// 以对象o的方法调用函数f(), 并传入两个参数</span></div><div class="line">f.call(o, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 直接传入</span></div><div class="line">f.apply(o, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 参数包装成数组形式，方便传入任意数量参数</span></div><div class="line"><span class="comment">// bind 对比 call 和 apply，不仅将第一个实参绑定至 this，也将其他实参绑定至引用对象（柯里化）</span></div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在ES3中实现 array.map() 方法，该实现为懒加载，因此只在初始化生成，避免每次调用 map 都要判断</span></div><div class="line"><span class="keyword">var</span> map = <span class="built_in">Array</span>.prototype.map</div><div class="line">  ? <span class="function"><span class="keyword">function</span> (<span class="params">array, func</span>) </span>&#123; <span class="keyword">return</span> array.map(func) &#125;</div><div class="line">  : <span class="function"><span class="keyword">function</span> (<span class="params">array, func</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> results = []</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = array.length; i &lt; len; i++) &#123;</div><div class="line">      <span class="keyword">if</span> (i <span class="keyword">in</span> array) &#123;</div><div class="line">        <span class="comment">// array.map(item, index. array)</span></div><div class="line">        results[i] = func.call(<span class="literal">null</span>, array[i], i, array)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> results</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>函数的 <code>toString()</code> 方法返回定义该函数的源码</li>
<li>一般不用 <code>Function()</code> 构造函数生成函数</li>
<li>高阶函数即操作函数的函数，接收函数作为参数</li>
</ul>
<h2 id="类和模块"><a href="#类和模块" class="headerlink" title="类和模块"></a>类和模块</h2><blockquote>
<p>类的所有实例对象都从同一个原型对象上继承属性，原型对象是类的核心</p>
</blockquote>
<ul>
<li>构造函数调用的一个重要特征是，构造函数的原型会被用作新对象的原型</li>
<li>构造函数是类的公共标识，原型对象是类的唯一标识</li>
<li><p><code>constructor</code> 属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line">F.prototype.constructor === F <span class="comment">// true</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> F()</div><div class="line">o.constructor === F <span class="comment">// true，一般类的实例的 constructor 指向类的构造函数</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">G</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line">G.prototype = &#123;&#125; <span class="comment">// 直接赋值原型会导致 constructor 丢失</span></div><div class="line">G.prototype.constructor === G <span class="comment">// false</span></div><div class="line">G.prototype = &#123;</div><div class="line">  <span class="string">'constructor'</span>: G <span class="comment">// 显式设置构造函数反式引用修复上面问题</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>instanceof</code> 检测的实际是对象的继承关系，而不是创建对象的构造函数</p>
</li>
<li><code>iframe</code> 中一个 <code>Array</code> 的实例不是另一个 <code>iframe</code> 中的 <code>Array</code> 的实例</li>
<li>一般通过闭包的方式实现私有状态</li>
<li>抽象类是指一种在最高祖先级别定义这个类应该具有的方法，但这些方法没有具体实现，如果在子孙类中没有通过重载复写，一般在调用时会触发祖先定义的方法提示</li>
<li>ES3 中，对象的读写等属性并不能自行配置，因此不能将自定义类模拟成内置对象（<code>for...in</code> 会遍历到）</li>
</ul>
<blockquote>
<p>犀牛书对于继承这一方面的介绍一开始就非常的深奥难懂，其实不是特别良好的教程，推荐阅读《JavaScript 高级程序设计》中关于原型与继承的部分</p>
</blockquote>
<h2 id="正则表达式的模式匹配"><a href="#正则表达式的模式匹配" class="headerlink" title="正则表达式的模式匹配"></a>正则表达式的模式匹配</h2><blockquote>
<p>JavaScript 的正则是 Perl 的大型子集</p>
</blockquote>
<ul>
<li>ES3 中，对于同样的正则表达式直接量，对应的是同一个正则对象。在 ES5 中，则跟对象等引用类似，不会因为同样是空对象就认为是同一个对象。（由于即使是 IE 的实现也符合 ES5 标准，因此实际上只需要考虑 ES5 的规定即可）</li>
<li>对于特殊的字符，需要用反斜杠进行转义</li>
<li>常见字符匹配语法<ul>
<li><code>[abc]</code> =&gt; 方括号内任意字符（这里是 a，b，c）</li>
<li><code>[^abc]</code> =&gt; 除方括号的任意字符（这里指不含 a 或 b 或c的任意一个）</li>
<li><code>.</code> =&gt; 除了换行符外的其他字符</li>
<li><code>\w</code> =&gt; 等价于 <code>[a-zA-Z0-9]</code>，指字母和数字</li>
<li><code>\W</code> =&gt; 上一条的取反</li>
<li><code>\s</code> =&gt; 一般匹配空格</li>
<li><code>\S</code> =&gt; 上一条的取反，一般指所有非空字符，范围比 <code>\w</code> 大一些</li>
<li><code>\d</code> =&gt; 等价于 <code>[0-9]</code>，匹配数字</li>
<li><code>\D</code> =&gt; 上一条取反，匹配非数字</li>
</ul>
</li>
<li>重复语法<ul>
<li><code>{n, m}</code> =&gt; 至少出现 <code>n</code> 次，但最多 <code>m</code> 次</li>
<li><code>{n,}</code> =&gt; 至少出现 <code>n</code> 次</li>
<li><code>{n}</code> =&gt; 只能出现 <code>n</code> 次</li>
<li><code>?</code> =&gt; 出现1次或不出现，等价于 <code>{0, 1}</code></li>
<li><code>+</code> =&gt; 至少出现1次，等价于 <code>{1,}</code></li>
<li><code>*</code> =&gt; 可以随便出现（不出现，1次或多次），等价于 <code>{0, }</code></li>
</ul>
</li>
<li>选择分组<ul>
<li><code>|</code> 选择符号，区分可选的分组，这些分组会短路判断，只有在前面的分组不匹配时才尝试后面的分组</li>
<li><code>()</code> 分组符号，将模式打包，定义子模式或子表达式（同时后面可以使用快捷写法）</li>
</ul>
</li>
<li>指定位置<ul>
<li><code>^</code> =&gt; 指定作为开头</li>
<li><code>$</code> =&gt; 指定作为结尾</li>
<li><code>\b</code> =&gt; 匹配边界</li>
<li><code>\B</code> =&gt; 上一条的取反</li>
</ul>
</li>
<li>修饰符<ul>
<li><code>i</code> =&gt; 忽略大小写</li>
<li><code>g</code> =&gt; 全局匹配</li>
<li><code>m</code> =&gt; 多行模式</li>
</ul>
</li>
<li>String 方法<ul>
<li><code>.search()</code> =&gt; 返回匹配字符串所在的位置，若无匹配则返回 <code>-1</code></li>
<li><code>.replace(reg, string)</code> =&gt; 执行检索和替换，参数可以是函数</li>
<li><code>.match()</code> =&gt; 全局检索时返回匹配结果的数组，否则返回首次匹配到的带自模式的</li>
<li><code>.split()</code> =&gt; 根据匹配项分割字符串</li>
</ul>
</li>
<li>一般推荐使用直接量法构造正则</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2016/04/03/《JavaScript权威指南》阅读笔记（下）/" class="prev">PREV</a><a href="/2015/12/27/《JavaScript高级程序设计》阅读笔记（下）/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="https://github.com/Hyifu">Hyifu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a></p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>